#####################################################################
#
# CSCB58 Winter 2025 Assembly Final Project
# University of Toronto, Scarborough
#
# Student: Yaseen Sadat, 1010358596, sadatyas, yaseen.sadat@mail.utoronto.ca
#
# Bitmap Display Configuration:
# - Unit width in pixels: 4
# - Unit height in pixels: 4
# - Display width in pixels: 512
# - Display height in pixels: 256
# - Base Address for Display: 0x10008000 ($gp)
#
# Milestones reached:
# - Milestone 1
#
# Approved features for Milestone 3:
# 1. Player now has a 4x4 sprite with eyes that differ based on facing:
#    - Right facing (player_facing==0): eyes at (row1, col1) and (row1, col3)
#    - Left facing  (player_facing==1): eyes at (row1, col0) and (row1, col2)
#
# 2. Floating Platform Collision (one-way):
#    - Platform A (row 50, cols 10 to 30) now collides with the player only when
#      falling from above. If the player's bottom (player_row+3) goes from above row 50
#      to row 50 or below and the player horizontally overlaps the platform,
#      the player is set to stand on the platform (player_row = 46).
#
# Additional information:
# - Step-by-step build in progress
#
#####################################################################

.eqv BASE_ADDRESS 0x10008000    # Framebuffer base address

.data
# Player position and physics variables
player_row:      .word 60        # Y-position (row)
player_col:      .word 2         # X-position (column)
player_velocity: .word 0         # Y velocity (positive = falling, negative = jumping up)
is_jumping:      .word 0         # 1 if in the air, 0 if grounded

# New variable to indicate facing direction: 0 = right, 1 = left
player_facing:   .word 0

# Temporary storage for the current player's base position
current_player_row: .word 0
current_player_col: .word 0

# Buffer to store the 4×4 background region under the player (16 words = 64 bytes)
player_bg_buffer: .space 64

# Movement delay variables
move_delay_counter: .word 0    # Countdown counter to control repeat movement
move_delay_value:   .word 2    # Delay constant (adjust for speed)

# Enemy variables:
    enemy_row:        .word 20      # Enemy is fixed on row 20
    enemy_col:        .word 0       # Starting column for enemy
    enemy_velocity:   .word 2       # Horizontal speed (in pixels per frame)
    enemy_bg_buffer:  .space 64     # 4x4 background for enemy (16 words, 64 bytes)
    # New enemy2 variables
    enemy2_row:        .word 45       # Start enemy2 at row 45
    enemy2_col:        .word 0        # Initial column for enemy2 (adjust as desired)
    enemy2_velocity:   .word 2        # Horizontal speed (same as enemy1)
    enemy2_bg_buffer:  .space 64      # Buffer for enemy2’s 4x4 background (16 words)


# Multi-shade reds for a more detailed red planet (top left)
darkest_red:   .word 0x008B0000   # Dark red
dark_red:      .word 0x00B22222   # Firebrick
mid_red:       .word 0x00CD5C5C   # IndianRed
light_red:     .word 0x00FA8072   # Salmon

# Define black color for facial features
black: .word 0x00000000

hearts: .word 4
enemy_collision_count: .word 0


# New variables for damage cooldown:
damage_cooldown: .word 0    # When > 0, player is temporarily invulnerable.
damage_delay:    .word 50   # Delay value in frames (~2 seconds)

# -------------------------------------------------------------------
# Earth planet colors (for an Earth‐like planet, top right):
#   - earth_dark:    dark ocean
#   - earth_ocean:   bright ocean blue
#   - earth_land:    green (land)
#   - earth_clouds:  white (clouds)
# -------------------------------------------------------------------
earth_dark:    .word 0x00004080   # Dark ocean (R=0, G=64, B=128)
earth_ocean:   .word 0x000080FF   # Ocean blue (R=0, G=128, B=255)
earth_land:    .word 0x00008000   # Land green (R=0, G=128, B=0)
earth_clouds:  .word 0x00FFFFFF   # Clouds (white)

.text
main:
    ################################################################
    # START SCREEN
    ################################################################
    jal start_screen       # Call the start screen subroutine

main_game_loop:
    ################################################################
    # INITIALIZE CONSTANTS
    ################################################################
    li   $s0, BASE_ADDRESS        # Framebuffer base address
    li   $s1, 0x00808080          # Grey color for platforms
    li   $s2, 0x00FF0000          # Red color for player
    li   $s3, 0x00000080          # Dark blue background

    ################################################################
    # DRAW BACKGROUND (64 rows × 128 cols)
    ################################################################
    li   $t4, 0                 # row = 0
bg_row_loop:
    li   $t5, 0                 # col = 0
bg_col_loop:
    mul  $t6, $t4, 512          # row offset (512 bytes per row)
    mul  $t7, $t5, 4            # column offset (4 bytes per pixel)
    add  $t8, $s0, $t6          # base address + row offset
    add  $t8, $t8, $t7          # + column offset
    sw   $s3, 0($t8)            # set pixel to dark blue
    addi $t5, $t5, 1
    blt  $t5, 128, bg_col_loop
    addi $t4, $t4, 1
    blt  $t4, 64, bg_row_loop


################################################################
# DRAW STARS (plus-shaped, 4x4 pixel stars, each row has unique spacing)
################################################################

# Row 1
li $s4, 4
li $s5, 4
li $t8, 20
jal draw_star_row

# Row 2
li $s4, 20
li $s5, 10
li $t8, 15
jal draw_star_row

# Row 3
li $s4, 36
li $s5, 2
li $t8, 20
jal draw_star_row

# Row 4
li $s4, 52
li $s5, 8
li $t8, 18
jal draw_star_row

j stars_done

################################################################
# Subroutine: draw_star_row
# $s4 = fixed row, $s5 = starting col, $t8 = column gap
################################################################
draw_star_row:
    li $t0, 124              # Max col
    move $t7, $s5            # current star col

next_star:
    bgt $t7, $t0, end_star_row
    li  $t9, 0x00FFFF00      # Yellow color

    # Draw vertical line (center of plus)
    li   $t1, 0
draw_v:
    bgt  $t1, 2, done_v
    add  $t2, $s4, $t1        # row = base row + offset
    addi $t3, $t7, 1          # col = base col + 1
    mul  $t4, $t2, 512        # row offset
    mul  $t5, $t3, 4          # col offset
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t1, $t1, 1
    j draw_v
done_v:
    # Draw horizontal line (center of plus)
    li $t1, 0
draw_h:
    bgt  $t1, 2, done_h
    addi $t2, $s4, 1          # fixed center row
    add  $t3, $t7, $t1        # col = base col + offset
    mul  $t4, $t2, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t1, $t1, 1
    j draw_h
done_h:
    add $t7, $t7, $t8         # next star col
    j next_star
end_star_row:
    jr $ra

stars_done:

    ################################################################
    # DRAW BLACK RECTANGLE (Top-right part of background)
    # Rows 1–10, Cols 105–125
    ################################################################
    li   $t0, 3           # Start row
black_rect_row_loop:
    li   $t1, 95         # Start col
black_rect_col_loop:
    mul  $t2, $t0, 512    # row offset in bytes
    mul  $t3, $t1, 4      # col offset in bytes
    add  $t4, $s0, $t2    # base + row offset
    add  $t4, $t4, $t3    # + col offset
    li   $t5, 0x00000000  # black color
    sw   $t5, 0($t4)      # draw black pixel
    addi $t1, $t1, 1
    blt  $t1, 127, black_rect_col_loop  # end at col 125
    addi $t0, $t0, 1
    ble  $t0, 9, black_rect_row_loop

    ################################################################
    # DRAW WHITE BORDER AROUND BLACK RECTANGLE (1 pixel bigger)
    # This border will now be drawn after the black rectangle,
    # so it will be visible on all sides.
    ################################################################
    li   $t5, 0x00FFFFFF      # White color
    li   $t0, 2               # Start row (1 row above the black rect)
white_border_row_loop:
    li   $t1, 94            # Start col (1 col left of the black rect)
white_border_col_loop:
    # Draw only border pixels (top, bottom, left, or right)
    li   $t6, 2           # top border row
    li   $t7, 10          # bottom border row
    li   $t8, 94          # left border col
    li   $t9, 126         # right border col
    beq  $t0, $t6, draw_white_border
    beq  $t0, $t7, draw_white_border
    beq  $t1, $t8, draw_white_border
    beq  $t1, $t9, draw_white_border
    j skip_white_border

draw_white_border:
    mul  $s1, $t0, 512     # row offset in bytes
    mul  $s2, $t1, 4       # col offset in bytes
    add  $s3, $s0, $s1
    add  $s3, $s3, $s2
    sw   $t5, 0($s3)       # write white pixel

skip_white_border:
    addi $t1, $t1, 1
    ble  $t1, 126, white_border_col_loop
    addi $t0, $t0, 1
    ble  $t0, 10, white_border_row_loop


##############################################################
# DRAW HEARTS (4 red hearts, top-right, inside black rectangle)
##############################################################
li   $t0, 0x00FF0000    # Red color
li   $t1, 4             # Start row
li   $t2, 98            # NEW: Start col (moved left from 107 to 93)
li   $t3, 4             # NEW: Number of hearts = 4


heart_loop:
    beq  $t3, $zero, hearts_done

    # Draw: R R _ R R
    li $t4, 0   # row offset
    li $t5, 0
heart_row0:
    bge $t5, 5, heart_row0_done
    li  $t6, 1
    beq $t5, 2, skip_pixel0
    j draw_pixel0
skip_pixel0:
    li $t6, 0
draw_pixel0:
    beq $t6, $zero, next_col0
    add $t7, $t2, $t5
    add $t8, $t1, $t4
    mul $t9, $t8, 512
    mul $s1, $t7, 4
    add $s2, $s0, $t9
    add $s2, $s2, $s1
    sw  $t0, 0($s2)
next_col0:
    addi $t5, $t5, 1
    j heart_row0
heart_row0_done:

    # Draw: R R R R R
    li $t4, 1
    li $t5, 0
heart_row1:
    bge $t5, 5, heart_row1_done
    add $t7, $t2, $t5
    add $t8, $t1, $t4
    mul $t9, $t8, 512
    mul $s1, $t7, 4
    add $s2, $s0, $t9
    add $s2, $s2, $s1
    sw  $t0, 0($s2)
    addi $t5, $t5, 1
    j heart_row1
heart_row1_done:

    # Draw: _ R R R _
    li $t4, 2
    li $t5, 0
heart_row2:
    bge $t5, 5, heart_row2_done
    li  $t6, 0
    bgt $t5, 0, check_col2
    j next_col2
check_col2:
    blt $t5, 4, set_draw2
    j next_col2
set_draw2:
    li $t6, 1
next_col2:
    beq $t6, $zero, skip_pixel2
    add $t7, $t2, $t5
    add $t8, $t1, $t4
    mul $t9, $t8, 512
    mul $s1, $t7, 4
    add $s2, $s0, $t9
    add $s2, $s2, $s1
    sw  $t0, 0($s2)
skip_pixel2:
    addi $t5, $t5, 1
    j heart_row2
heart_row2_done:

    # Draw: _ _ R _ _
    li $t4, 3
    addi $t7, $t2, 2
    add $t8, $t1, $t4
    mul  $t9, $t8, 512
    mul  $s1, $t7, 4
    add  $s2, $s0, $t9
    add  $s2, $s2, $s1
    sw   $t0, 0($s2)

    # Advance to next heart (7 columns apart)
    addi $t2, $t2, 7
    addi $t3, $t3, -1
    j heart_loop

hearts_done:

    ################################################################
    # DRAW RED PLANET (TOP LEFT, swirl pattern)
    ################################################################
    li   $t0, 2         # red planet base row
    li   $t1, 2         # red planet base col
    li   $t2, 24        # bounding box size
    li   $t3, 12        # radius
    addu $t8, $t1, $t3  # center_col = base col + 12
    addu $t9, $t0, $t3  # center_row = base row + 12
    li   $t4, 0         # Outer loop counter (i)
planet_row_loop:
    bge  $t4, $t2, planet_done
    addu $t6, $t0, $t4      # current_row = base row + i
    li   $t5, 0           # Inner loop counter (j)
planet_col_loop:
    bge  $t5, $t2, planet_next_row
    addu $t7, $t1, $t5      # current_col = base col + j
    sub  $a0, $t7, $t8      # dx = current_col - center_col
    sub  $a1, $t6, $t9      # dy = current_row - center_row
    mul  $v1, $a0, $a0      # dx^2
    mul  $t3, $a1, $a1      # dy^2 (temporary)
    addu $v1, $v1, $t3      # distance^2
    li   $t3, 144          # 12^2 = 144
    bgt  $v1, $t3, planet_skip_pixel
    sll  $v0, $a1, 1       # pattern: (2*dy + dx) >> 2
    addu $v0, $v0, $a0
    sra  $v0, $v0, 2
    andi $v0, $v0, 3      # mod 4
    li   $t3, 0
    beq  $v0, $zero, pick_darkest
    li   $t3, 1
    beq  $v0, $t3, pick_dark
    li   $t3, 2
    beq  $v0, $t3, pick_mid
pick_light:
    lw   $t3, light_red
    j    planet_set_pixel
pick_mid:
    lw   $t3, mid_red
    j    planet_set_pixel
pick_dark:
    lw   $t3, dark_red
    j    planet_set_pixel
pick_darkest:
    lw   $t3, darkest_red
planet_set_pixel:
    mul  $v1, $t6, 512         # row offset in bytes
    sll  $a0, $t7, 2           # col offset in bytes
    addu $v1, $s0, $v1        # base + row offset
    addu $v1, $v1, $a0        # final pixel address
    sw   $t3, 0($v1)          # store chosen red color
planet_skip_pixel:
    addi $t5, $t5, 1         # j++
    j    planet_col_loop
planet_next_row:
    addi $t4, $t4, 1         # i++
    j    planet_row_loop
planet_done:

    ################################################################
    # DRAW EARTH-LIKE PLANET (TOP RIGHT, swirl pattern)
    ################################################################
    li   $t0, 12         # earth planet base row
    li   $t1, 102       # earth planet base col
    li   $t2, 24        # bounding box size
    li   $t3, 12        # radius
    addu $t8, $t1, $t3  # center_col = base col + 12
    addu $t9, $t0, $t3  # center_row = base row + 12
    li   $t4, 0         # Outer loop counter (i)
earth_row_loop:
    bge  $t4, $t2, earth_done
    addu $t6, $t0, $t4      # current_row = base row + i
    li   $t5, 0           # Inner loop counter (j)
earth_col_loop:
    bge  $t5, $t2, earth_next_row
    addu $t7, $t1, $t5      # current_col = base col + j
    sub  $a0, $t7, $t8      # dx = current_col - center_col
    sub  $a1, $t6, $t9      # dy = current_row - center_row
    mul  $v1, $a0, $a0      # dx^2
    mul  $t3, $a1, $a1      # dy^2 (temporary)
    addu $v1, $v1, $t3      # distance^2
    li   $t3, 144          # 12^2 = 144
    bgt  $v1, $t3, earth_skip_pixel
    sll  $v0, $a1, 1       # pattern: (2*dy + dx) >> 2
    addu $v0, $v0, $a0
    sra  $v0, $v0, 2
    andi $v0, $v0, 3      # mod 4
    li   $t3, 0
    beq  $v0, $zero, pick_earth_dark
    li   $t3, 1
    beq  $v0, $t3, pick_earth_ocean
    li   $t3, 2
    beq  $v0, $t3, pick_earth_land
pick_earth_clouds:
    lw   $t3, earth_clouds
    j    earth_set_pixel
pick_earth_land:
    lw   $t3, earth_land
    j    earth_set_pixel
pick_earth_ocean:
    lw   $t3, earth_ocean
    j    earth_set_pixel
pick_earth_dark:
    lw   $t3, earth_dark
earth_set_pixel:
    mul  $v1, $t6, 512      # row offset in bytes
    sll  $a0, $t7, 2        # col offset in bytes
    addu $v1, $s0, $v1      # base address
    addu $v1, $v1, $a0      # final pixel address
    sw   $t3, 0($v1)        # store chosen earth color
earth_skip_pixel:
    addi $t5, $t5, 1       # j++
    j    earth_col_loop
earth_next_row:
    addi $t4, $t4, 1       # i++
    j    earth_row_loop
earth_done:

################################################################
# DRAW PLATFORMS (A–E)
################################################################
li $t9, 0x00808080       # Grey color

# Platform A: row 50, columns 10 to 30 (floating platform)
li $t4, 50
li $t5, 10
platA_loop:
    mul $t6, $t4, 512
    mul $t7, $t5, 4
    add $t8, $s0, $t6
    add $t8, $t8, $t7
    sw  $t9, 0($t8)
    addi $t5, $t5, 1
    blt  $t5, 31, platA_loop

# Platform B: row 40, columns 40 to 70
li $t4, 40
li $t5, 40
platB_loop:
    mul $t6, $t4, 512
    mul $t7, $t5, 4
    add $t8, $s0, $t6
    add $t8, $t8, $t7
    sw  $t9, 0($t8)
    addi $t5, $t5, 1
    blt  $t5, 71, platB_loop

# Platform C: row 30, columns 80 to 105
li $t4, 30
li $t5, 80
platC_loop:
    mul $t6, $t4, 512
    mul $t7, $t5, 4
    add $t8, $s0, $t6
    add $t8, $t8, $t7
    sw  $t9, 0($t8)
    addi $t5, $t5, 1
    blt  $t5, 106, platC_loop

# Platform D: row 25, columns 20 to 45
li $t4, 25
li $t5, 20
platD_loop:
    mul $t6, $t4, 512
    mul $t7, $t5, 4
    add $t8, $s0, $t6
    add $t8, $t8, $t7
    sw  $t9, 0($t8)
    addi $t5, $t5, 1
    blt  $t5, 46, platD_loop

# Platform E: row 45, columns 95 to 120
li $t4, 45
li $t5, 95
platE_loop:
    mul $t6, $t4, 512
    mul $t7, $t5, 4
    add $t8, $s0, $t6
    add $t8, $t8, $t7
    sw  $t9, 0($t8)
    addi $t5, $t5, 1
    blt  $t5, 121, platE_loop

    ################################################################
    # INIT PREVIOUS PLAYER POSITION
    ################################################################
    li   $s6, 60
    li   $s7, 2

######################################################################
# MAIN GAME LOOP
######################################################################
game_loop:
    ################################################################
    # 1) Handle Continuous Input with Delay
    ################################################################
    li   $t0, 0xffff0000      # Keyboard MMIO base
    lw   $t1, 0($t0)          # Read key status
    beq  $t1, $zero, reset_delay   # No key pressed: reset delay counter

    lw   $t2, move_delay_counter   # Load delay counter
    bnez $t2, decrement_delay       # If counter is not zero, skip input

    # A key is pressed and delay counter is 0; process input:
    lw   $t3, 4($t0)          # ASCII code
    li   $t4, 97              # 'a'
    beq  $t3, $t4, move_left
    li   $t4, 100             # 'd'
    beq  $t3, $t4, move_right
    li   $t4, 119             # 'w'
    beq  $t3, $t4, try_jump

go_to_start_screen:
    jal start_screen      # Go to start screen
    # After returning from start screen, reset state:
    li   $t0, 60          # initial player_row
    sw   $t0, player_row
    li   $t0, 2           # initial player_col
    sw   $t0, player_col
    li   $t0, 0           # reset player_velocity
    sw   $t0, player_velocity
    li   $t0, 0           # reset is_jumping
    sw   $t0, is_jumping
    j game_loop           # Jump back into the game loop


decrement_delay:
    lw   $t2, move_delay_counter
    addi $t2, $t2, -1
    sw   $t2, move_delay_counter
reset_delay:
    # If no key is pressed, reset the counter to 0
    li   $t2, 0
    sw   $t2, move_delay_counter
    j skip_input

skip_input:
    ################################################################
    # 2) Restore Old Player Background from Buffer
    # (Iterate 4 rows × 4 cols)
    ################################################################
    la   $t3, player_bg_buffer
    li   $t8, 0
restore_bg_loop_rows:
    li   $t9, 0
restore_bg_loop_cols:
    add  $t4, $s6, $t8
    add  $t5, $s7, $t9
    mul  $t4, $t4, 512
    mul  $t5, $t5, 4
    add  $t0, $s0, $t4
    add  $t0, $t0, $t5
    lw   $t1, 0($t3)
    sw   $t1, 0($t0)
    addi $t3, $t3, 4
    addi $t9, $t9, 1
    blt  $t9, 4, restore_bg_loop_cols
    addi $t8, $t8, 1
    blt  $t8, 4, restore_bg_loop_rows

    ################################################################
    # 3) Apply Gravity (with floating platform collision)
    ################################################################
    jal  apply_gravity

    ################################################################
    # 4) Clamp & Save New Player Position
    # (Max row = 60, max col = 124 for 4x4 sprite)
    ################################################################
    la   $t0, player_row
    la   $t1, player_col
    lw   $t4, 0($t0)
    lw   $t5, 0($t1)
    li   $t6, 0
    blt  $t4, $t6, fix_top
    li   $t6, 60
    bgt  $t4, $t6, fix_bottom
    j    skip_row_clamp
fix_top:
    li   $t4, 0
    sw   $t4, player_row
    j    skip_row_clamp
fix_bottom:
    li   $t4, 60
    sw   $t4, player_row
skip_row_clamp:

    li   $t6, 0
    blt  $t5, $t6, fix_left
    li   $t6, 124
    bgt  $t5, $t6, fix_right
    j    skip_col_clamp
fix_left:
    li   $t5, 0
    sw   $t5, player_col
    j    skip_col_clamp
fix_right:
    li   $t5, 124
    sw   $t5, player_col
skip_col_clamp:

    lw   $t5, 0($t1)
    la   $t7, current_player_row
    sw   $t4, 0($t7)
    la   $t7, current_player_col
    sw   $t5, 0($t7)

    ################################################################
    # 5) Save New Background into Buffer
    # (Iterate 4 rows x 4 cols)
    ################################################################
    la   $t3, player_bg_buffer
    li   $t8, 0
save_bg_loop_rows:
    la   $t7, current_player_row
    lw   $t5, 0($t7)
    la   $t7, current_player_col
    lw   $t6, 0($t7)
    li   $t9, 0
save_bg_loop_cols:
    add  $t2, $t5, $t8
    add  $t1, $t6, $t9
    mul  $t2, $t2, 512
    mul  $t1, $t1, 4
    add  $t0, $s0, $t2
    add  $t0, $t0, $t1
    lw   $t4, 0($t0)
    sw   $t4, 0($t3)
    addi $t3, $t3, 4
    addi $t9, $t9, 1
    blt  $t9, 4, save_bg_loop_cols
    addi $t8, $t8, 1
    blt  $t8, 4, save_bg_loop_rows

    ################################################################
    # 6) Draw Player at New Position (4x4 sprite with eyes)
    ################################################################
    li   $t8, 0            # Row offset (0..3)
draw_loop_rows:
    la   $t7, current_player_row
    lw   $t5, 0($t7)       # Base row for player
    la   $t7, current_player_col
    lw   $t6, 0($t7)       # Base col for player
    li   $t9, 0            # Column offset (0..3)
draw_loop_cols:
    add  $t2, $t5, $t8     # current_row = base_row + row offset
    add  $t1, $t6, $t9     # current_col = base_col + col offset
    mul  $t2, $t2, 512     # row offset in bytes
    mul  $t1, $t1, 4       # col offset in bytes
    add  $t0, $s0, $t2     # pixel address = base + row offset
    add  $t0, $t0, $t1     # + column offset

    # Determine pixel color.
    # For all rows except row 1, draw red ($s2).
    # For row 1, choose eye color based on facing.
    li   $t3, 1
    bne  $t8, $t3, player_set_red   # if row offset != 1, set red

    # Now in row 1: load player_facing.
    lw   $t3, player_facing         # $t3 = 0 for right, 1 for left
    beq  $t3, $zero, right_facing    # if facing == 0, branch to right_facing

    # Left facing branch:
left_facing:
    li   $t4, 0
    beq  $t9, $t4, player_set_black  # if col offset == 0, set black
    li   $t4, 2
    beq  $t9, $t4, player_set_black  # if col offset == 2, set black
    j    player_set_red

right_facing:
    li   $t4, 1
    beq  $t9, $t4, player_set_black  # if col offset == 1, set black
    li   $t4, 3
    beq  $t9, $t4, player_set_black  # if col offset == 3, set black
    j    player_set_red

player_set_black:
    lw   $t7, black       # load black color
    j    store_pixel
player_set_red:
    move $t7, $s2         # set red color
store_pixel:
    sw   $t7, 0($t0)      # write chosen color

    addi $t9, $t9, 1
    blt  $t9, 4, draw_loop_cols
    addi $t8, $t8, 1
    blt  $t8, 4, draw_loop_rows

    ################################################################
    # 7) Update Previous Player Position
    ################################################################
    la   $t7, current_player_row
    lw   $t4, 0($t7)
    move $s6, $t4
    la   $t7, current_player_col
    lw   $t4, 0($t7)
    move $s7, $t4
  
    ################################################################
    # 7.1) Restore Old Enemy Background (4×4 region) from enemy_bg_buffer
    ################################################################
    la   $t0, enemy_bg_buffer    # pointer to enemy bg buffer
    li   $t1, 0                  # row offset index (0..3)
enemy_restore_bg_loop_rows:
    li   $t2, 0                  # column offset index (0..3)
enemy_restore_bg_loop_cols:
    # Compute current enemy pixel address:
    la   $t3, enemy_row         # load enemy_row address
    lw   $t4, 0($t3)            # enemy's base row
    add  $t4, $t4, $t1          # current row = enemy_row + row offset
    la   $t5, enemy_col         # load enemy_col address
    lw   $t6, 0($t5)            # enemy's base col
    add  $t6, $t6, $t2          # current col = enemy_col + col offset
    mul  $t4, $t4, 512          # row offset (bytes)
    mul  $t6, $t6, 4            # col offset (bytes)
    add  $t7, $s0, $t4          # base address + row offset
    add  $t7, $t7, $t6          # final pixel address for enemy region
    lw   $t8, 0($t0)            # get stored pixel from enemy_bg_buffer
    sw   $t8, 0($t7)            # restore that pixel into the framebuffer
    addi $t0, $t0, 4            # advance enemy_bg_buffer pointer
    addi $t2, $t2, 1
    blt  $t2, 4, enemy_restore_bg_loop_cols
    li   $t2, 0                 # reset col offset for next row
    addi $t1, $t1, 1
    blt  $t1, 4, enemy_restore_bg_loop_rows

    ################################################################
    # 7.2) Update Enemy Position (Horizontal move)
    ################################################################
    la   $t0, enemy_col         # load enemy_col address
    lw   $t1, 0($t0)            # get current enemy col
    la   $t2, enemy_velocity    # load enemy_velocity address
    lw   $t3, 0($t2)            # get enemy horizontal speed
    add  $t1, $t1, $t3          # new enemy col = old + velocity
    li   $t4, 124              # right boundary (for 4×4 sprite)
    ble  $t1, $t4, enemy_update_done
    li   $t1, 0                # if beyond boundary, wrap to left
enemy_update_done:
    sw   $t1, 0($t0)           # store updated enemy col

    ################################################################
    # 7.3) Save New Enemy Background into enemy_bg_buffer
    # (Capture the 4×4 area at the enemy's new position)
    ################################################################
    la   $t0, enemy_bg_buffer   # reset pointer for enemy bg buffer
    li   $t1, 0                 # row offset index (0..3)
enemy_save_bg_loop_rows:
    li   $t2, 0                 # column offset index (0..3)
enemy_save_bg_loop_cols:
    la   $t3, enemy_row         # load enemy_row address
    lw   $t4, 0($t3)            # enemy's base row
    add  $t4, $t4, $t1          # current row = enemy_row + row offset
    la   $t5, enemy_col         # load enemy_col address
    lw   $t6, 0($t5)            # enemy's base col
    add  $t6, $t6, $t2          # current col = enemy_col + col offset
    mul  $t4, $t4, 512          # row offset (bytes)
    mul  $t6, $t6, 4            # col offset (bytes)
    add  $t7, $s0, $t4          # base address + row offset
    add  $t7, $t7, $t6          # final pixel address in framebuffer
    lw   $t8, 0($t7)            # read current pixel from framebuffer
    sw   $t8, 0($t0)            # save pixel into enemy_bg_buffer
    addi $t0, $t0, 4            # advance enemy_bg_buffer pointer
    addi $t2, $t2, 1
    blt  $t2, 4, enemy_save_bg_loop_cols
    addi $t1, $t1, 1
    blt  $t1, 4, enemy_save_bg_loop_rows

    ################################################################
    # 7.4) Draw Enemy Sprite (4×4 green block with black eyes)
    ################################################################
    # Load enemy base positions.
    la   $t0, enemy_row         # pointer to enemy_row
    lw   $t1, 0($t0)            # enemy's base row -> $t1
    la   $t0, enemy_col         # pointer to enemy_col (reuse $t0)
    lw   $t2, 0($t0)            # enemy's base col -> $t2

    # Load color constants.
    li   $t7, 0x00008000        # green color for enemy body (in $t7)
    li   $t8, 0x00000000        # black color for eyes (in $t8)

    # Set up constant registers (using saved registers $s4 and $s5).
    addi $s4, $zero, 1         # $s4 = 1
    addi $s5, $zero, 3         # $s5 = 3

    # Initialize row offset in $t3.
    addi $t3, $zero, 0         # row offset = 0
enemy_draw_loop_rows:
    bge  $t3, 4, enemy_draw_done_rows  # if row offset >= 4, exit loop

    # Initialize column offset in $t4.
    addi $t4, $zero, 0         # column offset = 0
enemy_draw_loop_cols:
    bge  $t4, 4, enemy_next_row   # if column offset >= 4, move to next row

    # Compute current pixel's absolute address:
    add  $t9, $t1, $t3        # current row = enemy base row ($t1) + row offset ($t3)
    mul  $t9, $t9, 512        # multiply by 512 to get byte offset for the row
    add  $t5, $t2, $t4        # current col = enemy base col ($t2) + col offset ($t4)
    mul  $t5, $t5, 4          # multiply by 4 to get byte offset for the column
    add  $t6, $s0, $t9        # $s0 is the framebuffer base; add row offset
    add  $t6, $t6, $t5        # add column offset to get final pixel address

    # For the enemy's second row (relative row 1) we want black eyes at col offset 1 and 3.
    beq  $t3, $s4, enemy_eye_row_check  # if row offset equals 1, branch to eye check
    # Otherwise, draw green.
    sw   $t7, 0($t6)
    j    enemy_next_pixel_label

enemy_eye_row_check:
    # Check if the current column offset equals 1 or equals 3.
    beq  $t4, $s4, enemy_draw_black   # if col offset equals 1, draw black
    beq  $t4, $s5, enemy_draw_black   # if col offset equals 3, draw black
    # Otherwise, draw green.
    sw   $t7, 0($t6)
    j    enemy_next_pixel_label

enemy_draw_black:
    sw   $t8, 0($t6)         # draw black pixel for an eye

enemy_next_pixel_label:
    addi $t4, $t4, 1         # increment column offset
    j    enemy_draw_loop_cols

enemy_next_row:
    addi $t3, $t3, 1         # increment row offset
    j    enemy_draw_loop_rows

enemy_draw_done_rows:

    ################################################################
    # --- Enemy2: Restore Old Background from enemy2_bg_buffer (4x4) ---
    ################################################################
    la   $t0, enemy2_bg_buffer    # pointer to enemy2 background buffer
    li   $t1, 0                   # row offset index (0..3)
enemy2_restore_bg_loop_rows:
    li   $t2, 0                   # column offset index (0..3)
enemy2_restore_bg_loop_cols:
    la   $t3, enemy2_row          # load enemy2_row address
    lw   $t4, 0($t3)              # enemy2's base row
    add  $t4, $t4, $t1            # current row = enemy2_row + row offset
    la   $t5, enemy2_col          # load enemy2_col address
    lw   $t6, 0($t5)              # enemy2's base col
    add  $t6, $t6, $t2            # current col = enemy2_col + col offset
    mul  $t4, $t4, 512            # row offset (bytes)
    mul  $t6, $t6, 4              # col offset (bytes)
    add  $t7, $s0, $t4            # base address + row offset
    add  $t7, $t7, $t6            # final pixel address for enemy2 region
    lw   $t8, 0($t0)              # get stored pixel from enemy2_bg_buffer
    sw   $t8, 0($t7)              # restore that pixel into the framebuffer
    addi $t0, $t0, 4              # advance enemy2_bg_buffer pointer
    addi $t2, $t2, 1
    blt  $t2, 4, enemy2_restore_bg_loop_cols
    li   $t2, 0                  # reset col offset for next row
    addi $t1, $t1, 1
    blt  $t1, 4, enemy2_restore_bg_loop_rows

    ################################################################
    # --- Enemy2: Update Position (Horizontal movement) ---
    ################################################################
    la   $t0, enemy2_col          # load enemy2_col address
    lw   $t1, 0($t0)              # get current enemy2 col
    la   $t2, enemy2_velocity     # load enemy2_velocity address
    lw   $t3, 0($t2)              # get enemy2 horizontal speed
    add  $t1, $t1, $t3            # new enemy2 col = old + velocity
    li   $t4, 124                # right boundary (for 4x4 sprite)
    ble  $t1, $t4, enemy2_update_done
    li   $t1, 0                  # if beyond boundary, wrap to left
enemy2_update_done:
    sw   $t1, 0($t0)             # store updated enemy2 col

    ################################################################
    # --- Enemy2: Save New Background into enemy2_bg_buffer (4x4) ---
    ################################################################
    la   $t0, enemy2_bg_buffer    # reset pointer for enemy2 background buffer
    li   $t1, 0                  # row offset index (0..3)
enemy2_save_bg_loop_rows:
    li   $t2, 0                  # column offset index (0..3)
enemy2_save_bg_loop_cols:
    la   $t3, enemy2_row          # load enemy2_row address
    lw   $t4, 0($t3)              # enemy2's base row
    add  $t4, $t4, $t1            # current row = enemy2_row + row offset
    la   $t5, enemy2_col          # load enemy2_col address
    lw   $t6, 0($t5)              # enemy2's base col
    add  $t6, $t6, $t2            # current col = enemy2_col + col offset
    mul  $t4, $t4, 512            # row offset (bytes)
    mul  $t6, $t6, 4              # col offset (bytes)
    add  $t7, $s0, $t4            # base address + row offset
    add  $t7, $t7, $t6            # final pixel address in framebuffer
    lw   $t8, 0($t7)              # read current pixel from framebuffer
    sw   $t8, 0($t0)              # save pixel into enemy2_bg_buffer
    addi $t0, $t0, 4              # advance enemy2_bg_buffer pointer
    addi $t2, $t2, 1
    blt  $t2, 4, enemy2_save_bg_loop_cols
    addi $t1, $t1, 1
    blt  $t1, 4, enemy2_save_bg_loop_rows

    ################################################################
    # --- Enemy2: Draw Sprite (4x4 green block with black eyes) ---
    ################################################################
    # Load enemy2 base positions.
    la   $t0, enemy2_row          # pointer to enemy2_row
    lw   $t1, 0($t0)              # enemy2's base row -> $t1
    la   $t0, enemy2_col          # pointer to enemy2_col
    lw   $t2, 0($t0)              # enemy2's base col -> $t2

    # Load color constants.
    li   $t7, 0x00008000         # green color for enemy2 body
    li   $t8, 0x00000000         # black color for eyes

    # Set up constant registers (reuse $s4 and $s5 as before)
    addi $s4, $zero, 1           # $s4 = 1
    addi $s5, $zero, 3           # $s5 = 3

    # Initialize row offset in $t3.
    addi $t3, $zero, 0           # row offset = 0
enemy2_draw_loop_rows:
    bge  $t3, 4, enemy2_draw_done_rows  # if row offset >= 4, exit loop

    # Initialize column offset in $t4.
    addi $t4, $zero, 0           # column offset = 0
enemy2_draw_loop_cols:
    bge  $t4, 4, enemy2_next_row   # if column offset >= 4, move to next row

    # Compute current pixel's absolute address:
    add  $t9, $t1, $t3           # current row = enemy2 base row ($t1) + row offset ($t3)
    mul  $t9, $t9, 512           # multiply by 512 to get byte offset for the row
    add  $t5, $t2, $t4           # current col = enemy2 base col ($t2) + col offset ($t4)
    mul  $t5, $t5, 4             # multiply by 4 to get byte offset for the column
    add  $t6, $s0, $t9           # add row offset to BASE_ADDRESS
    add  $t6, $t6, $t5           # add column offset to get final pixel address

    # For enemy2’s second row (row offset 1) draw black eyes at col offsets 1 and 3.
    beq  $t3, $s4, enemy2_eye_row_check  # if row offset equals 1, check for eyes
    sw   $t7, 0($t6)             # otherwise, draw green
    j    enemy2_next_pixel_label

enemy2_eye_row_check:
    beq  $t4, $s4, enemy2_draw_black   # if col offset equals 1, draw black
    beq  $t4, $s5, enemy2_draw_black   # if col offset equals 3, draw black
    sw   $t7, 0($t6)             # otherwise, draw green
    j    enemy2_next_pixel_label

enemy2_draw_black:
    sw   $t8, 0($t6)             # draw black pixel for eye

enemy2_next_pixel_label:
    addi $t4, $t4, 1             # increment column offset
    j    enemy2_draw_loop_cols

enemy2_next_row:
    addi $t3, $t3, 1             # increment row offset
    j    enemy2_draw_loop_rows

enemy2_draw_done_rows:

################################################################
# Collision Check: Player vs. Enemy
################################################################
    # Load player's top-left coordinates.
    la   $t0, player_row      # pointer to player_row
    lw   $t1, 0($t0)          # player's top row
    la   $t2, player_col      # pointer to player_col
    lw   $t3, 0($t2)          # player's left col

    # Load enemy's top-left coordinates.
    la   $t4, enemy_row       # pointer to enemy_row
    lw   $t5, 0($t4)          # enemy's top row
    la   $t6, enemy_col       # pointer to enemy_col
    lw   $t7, 0($t6)          # enemy's left col

    # Check if player's bottom (player_row+3) is above enemy's top.
    addi $t8, $t1, 3          # player's bottom row
    blt  $t8, $t5, no_enemy_collision  # if player's bottom < enemy's top, no collision

    # Check if player's top is below enemy's bottom (enemy_row+3).
    addi $t8, $t5, 3          # enemy's bottom row
    bgt  $t1, $t8, no_enemy_collision  # if player's top > enemy's bottom, no collision

    # Check if player's right (player_col+3) is left of enemy's left.
    addi $t8, $t3, 3          # player's right col
    blt  $t8, $t7, no_enemy_collision  # if player's right < enemy's left, no collision

    # Check if player's left is right of enemy's right (enemy_col+3).
    addi $t8, $t7, 3          # enemy's right col
    bgt  $t3, $t8, no_enemy_collision  # if player's left > enemy's right, no collision

    # --- Begin Damage Cooldown Check ---
    la   $t8, damage_cooldown   # load address of damage_cooldown
    lw   $t9, 0($t8)            # load current cooldown value
    bnez $t9, enemy_damage_active   # if cooldown active, branch to enemy_damage_active
    # --- End Damage Cooldown Check ---

    # No cooldown active: Apply damage.
    la   $t0, hearts            # Load address of hearts
    lw   $t1, 0($t0)            # Load current heart count
    addi $t1, $t1, -1           # Decrement heart count by 1
    sw   $t1, 0($t0)            # Store updated heart count
    blez $t1, game_over         # If hearts <= 0, branch to game_over
    move $a0, $t1               # Use new heart count as index (0 = leftmost)
    jal  erase_heart           # Erase corresponding heart from display

    # Set damage cooldown to delay value (50 frames ~2 seconds)
    li   $t2, 50
    la   $t8, damage_cooldown
    sw   $t2, 0($t8)

    # Reset enemy collision counter to 0 upon taking damage.
    la   $t8, enemy_collision_count
    li   $t9, 0
    sw   $t9, 0($t8)

    j    continue_game         # Jump to continue game processing

enemy_damage_active:
    # Damage cooldown is active: increment enemy collision counter.
    la   $t8, enemy_collision_count  # load address of collision counter
    lw   $t9, 0($t8)                 # load current collision count
    addi $t9, $t9, 1                 # increment counter by 1
    sw   $t9, 0($t8)                 # store updated counter
    li   $t0, 4                     # constant 4 for comparison
    beq  $t9, $t0, enemy_collision_reset  # if counter equals 4, reset game
    j    continue_game              # otherwise, continue game processing

enemy_collision_reset:
    # Reset the collision counter to 0.
    la   $t8, enemy_collision_count
    li   $t9, 0
    sw   $t9, 0($t8)
    # Cut to the start screen.
    jal  start_screen
    j    game_loop                # Jump back to the main game loop

################################################################
# Label: no_enemy_collision (if no collision detected)
################################################################
no_enemy_collision:
    # Decrement damage cooldown (if active)
    la   $t0, damage_cooldown
    lw   $t1, 0($t0)
    bnez $t1, dec_cooldown_done
    j    frame_delay_start
dec_cooldown_done:
    addi $t1, $t1, -1
    sw   $t1, 0($t0)
frame_delay_start:
    ################################################################
    # 8) Frame Delay
    ################################################################
    li   $v0, 32
    li   $a0, 40
    syscall
    j    game_loop

################################################################
# Label: continue_game (after processing a collision)
################################################################
continue_game:
    j    game_loop

################################################################
# Label: game_over (when hearts run out)
################################################################
game_over:
            # Clear the screen to red.
        li   $s0, BASE_ADDRESS

        li   $t3, 0x00FF0000    # Red color
        li   $t4, 0             # row counter
clear_screen_loop:
        li   $t5, 0             # col counter
clear_screen_cols:
        mul  $t6, $t4, 512      # row offset in bytes
        mul  $t7, $t5, 4        # column offset in bytes
        add  $t8, $s0, $t6      # base address + row offset
        add  $t8, $t8, $t7      # add column offset
        sw   $t3, 0($t8)        # set pixel to red
        addi $t5, $t5, 1
        blt  $t5, 128, clear_screen_cols
        addi $t4, $t4, 1
        blt  $t4, 64, clear_screen_loop

        # --- Draw the big letter G (16x16 pixels) ---
        # White color for the letter.
        li   $t9, 0x00FFFFFF

        # Define base coordinates for the big G.
        li   $t0, 20       # base row for G
        li   $t1, 10      # base col for G

        # The design is based on scaling your 8-row pattern by 2.
        # The scaled pattern (each row is relative to the G’s top row):
        #
        # Rows 0-1 (original row 0): full horizontal line (cols 0-15)
        # Rows 2-3 (original row 1): left block only (cols 0-1)
        # Rows 4-5 (original row 2): left block (cols 0-1) and right segment (cols 8-15)
        # Rows 6-7 (original row 3): left block (cols 0-1) and right block (cols 14-15)
        # Rows 8-9 (original row 4): left block (cols 0-1) and right block (cols 14-15)
        # Rows 10-11 (original row 5): left block (cols 0-1) and right segment (cols 8-15)
        # Rows 12-13 (original row 6): left block (cols 0-1) and right block (cols 14-15)
        # Rows 14-15 (original row 7): horizontal line (cols 2-15)

        # ---------------- Row 0: full horizontal line (16 pixels) ----------------
        li   $t2, 0         # column counter
G_big_row0:
        bge  $t2, 16, G_big_row0_done
        # Compute absolute row = base row + 0, absolute col = base col + $t2.
        move $t3, $t0     
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row0
G_big_row0_done:

        # ---------------- Row 1: full horizontal line (16 pixels) ----------------
        addi $t3, $t0, 1    # row = base row + 1
        li   $t2, 0
G_big_row1:
        bge  $t2, 16, G_big_row1_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row1
G_big_row1_done:

        # ---------------- Row 2: left block only (cols 0-1) ----------------
        addi $t3, $t0, 2    # row = base row + 2
        li   $t2, 0
G_big_row2:
        bge  $t2, 2, G_big_row2_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2   # only for t2 = 0,1
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row2
G_big_row2_done:

        # ---------------- Row 3: left block only (cols 0-1) ----------------
        addi $t3, $t0, 3    # row = base row + 3
        li   $t2, 0
G_big_row3:
        bge  $t2, 2, G_big_row3_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row3
G_big_row3_done:

        # ---------------- Row 4: left block (cols 0-1) & right segment (cols 8-15) ----------------
        addi $t3, $t0, 4    # row = base row + 4
        # Left block:
        li   $t2, 0
G_big_row4_left:
        bge  $t2, 2, G_big_row4_left_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row4_left
G_big_row4_left_done:
        # Right segment:
        li   $t2, 8
G_big_row4_right:
        bge  $t2, 16, G_big_row4_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row4_right
G_big_row4_done:

        # ---------------- Row 5: same as Row 4 ----------------
        addi $t3, $t0, 5    # row = base row + 5
        li   $t2, 0
G_big_row5_left:
        bge  $t2, 2, G_big_row5_left_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row5_left
G_big_row5_left_done:
        li   $t2, 8
G_big_row5_right:
        bge  $t2, 16, G_big_row5_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row5_right
G_big_row5_done:

        # ---------------- Row 6: left block (cols 0-1) & right block (cols 14-15) ----------------
        addi $t3, $t0, 6    # row = base row + 6
        li   $t2, 0
G_big_row6_left:
        bge  $t2, 2, G_big_row6_left_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row6_left
G_big_row6_left_done:
        li   $t2, 14
G_big_row6_right:
        bge  $t2, 16, G_big_row6_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row6_right
G_big_row6_done:

        # ---------------- Row 7: same as Row 6 ----------------
        addi $t3, $t0, 7    # row = base row + 7
        li   $t2, 0
G_big_row7_left:
        bge  $t2, 2, G_big_row7_left_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row7_left
G_big_row7_left_done:
        li   $t2, 14
G_big_row7_right:
        bge  $t2, 16, G_big_row7_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row7_right
G_big_row7_done:

        # ---------------- Row 8: same as Rows 6-7 for original row 4 (left block & right block) ----------------
        addi $t3, $t0, 8    # row = base row + 8
        li   $t2, 0
G_big_row8_left:
        bge  $t2, 2, G_big_row8_left_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row8_left
G_big_row8_left_done:
        li   $t2, 14
G_big_row8_right:
        bge  $t2, 16, G_big_row8_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row8_right
G_big_row8_done:

        # ---------------- Row 9: same as Row 8 ----------------
        addi $t3, $t0, 9    # row = base row + 9
        li   $t2, 0
G_big_row9_left:
        bge  $t2, 2, G_big_row9_left_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row9_left
G_big_row9_left_done:
        li   $t2, 14
G_big_row9_right:
        bge  $t2, 16, G_big_row9_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row9_right
G_big_row9_done:

# ---------------- Row 10: same as Row 9 ----------------
addi $t3, $t0, 10   # row = base row + 10
li   $t2, 0
G_big_row10_left:
    bge  $t2, 2, G_big_row10_left_done
    mul  $t4, $t3, 512
    add  $t5, $t1, $t2
    mul  $t5, $t5, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    G_big_row10_left
G_big_row10_left_done:
li   $t2, 14
G_big_row10_right:
    bge  $t2, 16, G_big_row10_done
    mul  $t4, $t3, 512
    add  $t5, $t1, $t2
    mul  $t5, $t5, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    G_big_row10_right
G_big_row10_done:



# ---------------- Row 11: same as Row 9 ----------------
addi $t3, $t0, 11   # row = base row + 11
li   $t2, 0
G_big_row11_left:
    bge  $t2, 2, G_big_row11_left_done
    mul  $t4, $t3, 512
    add  $t5, $t1, $t2
    mul  $t5, $t5, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    G_big_row11_left
G_big_row11_left_done:
li   $t2, 14
G_big_row11_right:
    bge  $t2, 16, G_big_row11_done
    mul  $t4, $t3, 512
    add  $t5, $t1, $t2
    mul  $t5, $t5, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    G_big_row11_right
G_big_row11_done:





        # ---------------- Row 12: left block (cols 0-1) & right block (cols 14-15) ----------------
        addi $t3, $t0, 12   # row = base row + 12
        li   $t2, 0
G_big_row12_left:
        bge  $t2, 2, G_big_row12_left_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row12_left
G_big_row12_left_done:
        li   $t2, 14
G_big_row12_right:
        bge  $t2, 16, G_big_row12_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row12_right
G_big_row12_done:

        # ---------------- Row 13: same as Row 12 ----------------
        addi $t3, $t0, 13   # row = base row + 13
        li   $t2, 0
G_big_row13_left:
        bge  $t2, 2, G_big_row13_left_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row13_left
G_big_row13_left_done:
        li   $t2, 14
G_big_row13_right:
        bge  $t2, 16, G_big_row13_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row13_right
G_big_row13_done:

        # ---------------- Row 14: horizontal segment (cols 2-15) ----------------
        addi $t3, $t0, 14   # row = base row + 14
	li   $t2, 2
G_big_row14:
        bge  $t2, 16, G_big_row14_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row14
G_big_row14_done:

        # ---------------- Row 15: same as Row 14 ----------------
        addi $t3, $t0, 15   # row = base row + 15
        li   $t2, 2
G_big_row15:
        bge  $t2, 16, G_big_row15_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row15
G_big_row15_done:

# ========= Draw Big "A" Beside the Big "G" on the Game Over Screen =========
# (Assumes $s0 holds BASE_ADDRESS and $t9 is still set to white: 0x00FFFFFF)

# Set base coordinates for the A (positioned beside the G)
li   $t0, 20      # Base row for A (same vertical alignment as G)
li   $t1, 31      # Base column for A (to the right of G, which ends near col 25)
li   $t2, 0

# Draw top horizontal line of A (8 pixels wide)
A_top_loop_go:
    bge  $t2, 7, A_top_done_go
    add  $t3, $t1, $t2      # current col = base col + offset
    mul  $t4, $t0, 512      # row offset (base row * 512)
    mul  $t5, $t3, 4        # col offset (current col * 4)
    add  $t6, $s0, $t4      # address = BASE_ADDRESS + row offset
    add  $t6, $t6, $t5      # add col offset
    sw   $t9, 0($t6)        # write white pixel
    addi $t2, $t2, 1
    j    A_top_loop_go
A_top_done_go:

# Draw the left vertical leg of A
li   $t0, 21      # start one row below the top
A_left_vert_go:
    bgt  $t0, 35, A_left_done_go   # Draw until row 35 (adjust for desired height)
    mul  $t4, $t0, 512
    li   $t7, 30     # left side stays at base col 27
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    A_left_vert_go
A_left_done_go:

# Draw the right vertical leg of A
li   $t0, 21      # reset row counter for the right leg
A_right_vert_go:
    bgt  $t0, 35, A_right_done_go
    mul  $t4, $t0, 512
    li   $t7, 38     # right side at col 35 (adjust for width)
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    A_right_vert_go
A_right_done_go:

# Draw the horizontal crossbar of A
li   $t0, 28      # choose a row for the crossbar (adjust as needed)
li   $t2, 30      # start at the left side of A
A_crossbar_go:
    bge  $t2, 39, A_crossbar_done_go  # Draw from col 27 up to (but not including) col 36
    mul  $t4, $t0, 512
    mul  $t5, $t2, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    A_crossbar_go
A_crossbar_done_go:

# ---- Draw M (row 20, col 44) ----
# This is the original W drawing code with label names changed to M.
li   $t0, 20         # Base row for M (changed from 15 to 20)
li   $t1, 44         # Base column for M (changed from 50 to 44)
li   $t2, 0
M_left:
    bge $t2, 16, M_left_done
    add $t3, $t0, $t2
    mul $t4, $t3, 512
    mul $t5, $t1, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j    M_left
M_left_done:

li   $t2, 0
M_right:
    bge $t2, 16, M_right_done
    add $t3, $t0, $t2
    li $t7, 51         # Right stroke now at col 51 (44 + 7)
    mul $t4, $t3, 512
    mul $t5, $t7, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j    M_right
M_right_done:

# M diagonal left-to-center (row 30 to 32, cols 48 to 50)
li   $t2, 0
M_diag_left:
    bge $t2, 3, M_diag_left_done
    addi $t3, $t2, 20    # row = 20 + 10 = 30, plus t2 offset
    addi $t4, $t2, 45    # col = 44 + 4 = 48, plus t2 offset
    mul  $t5, $t3, 512
    mul  $t6, $t4, 4
    add  $t7, $s0, $t5
    add  $t7, $t7, $t6
    sw   $t9, 0($t7)
    addi $t2, $t2, 1
    j    M_diag_left
M_diag_left_done:

# M diagonal right-to-center (row 30 to 32, cols 47 downwards)
li   $t2, 0
M_diag_right:
    bge $t2, 3, M_diag_right_done
    addi $t3, $t2, 20    # row = 20 + 10 = 30, plus t2 offset
    li   $t4, 50         # col = 44 + 3 = 47
    sub  $t4, $t4, $t2   # adjust by t2 (t2 = 0,1,2)
    mul  $t5, $t3, 512
    mul  $t6, $t4, 4
    add  $t7, $s0, $t5
    add  $t7, $t7, $t6
    sw   $t9, 0($t7)
    addi $t2, $t2, 1
    j    M_diag_right
M_diag_right_done:

# ---- Draw E (row 20, col 56) ----
# Base coordinates for E
li   $t0, 20        # Base row for E
li   $t1, 56        # Base column for E (moved 2 cols left from 58 to 56)
li   $t2, 0

# Draw left vertical stroke of E (16 pixels tall)
E_left_vert:
    bge $t2, 16, E_left_vert_done  # Draw 16 rows (from row 20 to row 35)
    add  $t3, $t0, $t2             # current row = base row + offset
    mul  $t4, $t3, 512             # compute row offset in bytes
    mul  $t5, $t1, 4               # compute col offset (left stroke at base col)
    add  $t6, $s0, $t4             # BASE_ADDRESS + row offset
    add  $t6, $t6, $t5             # add column offset
    sw   $t9, 0($t6)              # store white pixel (in $t9)
    addi $t2, $t2, 1
    j    E_left_vert
E_left_vert_done:

# Draw top horizontal stroke of E (8 pixels wide) at row = base row (20)
li   $t2, 0
E_top:
    bge $t2, 8, E_top_done
    add  $t3, $t1, $t2            # current col = base col + offset
    mul  $t4, $t0, 512            # row offset for row 20
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    E_top
E_top_done:

# Draw middle horizontal stroke of E (8 pixels wide) at row = base row + 8 (i.e. row 28)
li   $t2, 0
li   $t7, 20
addi $t8, $t7, 8             # middle row = 28
E_middle:
    bge $t2, 6, E_middle_done
    add  $t3, $t1, $t2         # current col = base col + offset
    mul  $t4, $t8, 512         # row offset for row 28
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    E_middle
E_middle_done:

# Draw bottom horizontal stroke of E (8 pixels wide) at row = base row + 15 (i.e. row 35)
li   $t2, 0
li   $t7, 20
addi $t8, $t7, 15           # bottom row = 35
E_bottom:
    bge $t2, 8, E_bottom_done
    add  $t3, $t1, $t2         # current col = base col + offset
    mul  $t4, $t8, 512         # row offset for row 35
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    E_bottom
E_bottom_done:

# ---- Draw thicker and taller O (14x10 with 2-pixel thick border) under the M ----
# Base coordinates for O:
li   $t0, 41        # Base row for O (moved 5 pixels lower)
li   $t1, 43        # Base col for O (same as before)
# Assumes $s0 holds BASE_ADDRESS and $t9 holds white (0x00FFFFFF)

# -------------------------------------
# Draw top border (2 rows: rows 41 and 42)
li   $t2, 0
O_top_border:
    bge  $t2, 2, O_top_border_done
    add  $t3, $t0, $t2
    li   $t4, 0
O_top_border_col:
    bge  $t4, 10, O_top_border_next
    add  $t5, $t1, $t4
    mul  $t6, $t3, 512
    mul  $t7, $t5, 4
    add  $t8, $s0, $t6
    add  $t8, $t8, $t7
    sw   $t9, 0($t8)
    addi $t4, $t4, 1
    j    O_top_border_col
O_top_border_next:
    addi $t2, $t2, 1
    j    O_top_border
O_top_border_done:

# -------------------------------------
# Draw bottom border (rows 53 and 54: base row + 12 and +13)
li   $t2, 0
O_bottom_border:
    bge  $t2, 2, O_bottom_border_done
    addi $t3, $t0, 12
    add  $t3, $t3, $t2
    li   $t4, 0
O_bottom_border_col:
    bge  $t4, 10, O_bottom_border_next
    add  $t5, $t1, $t4
    mul  $t6, $t3, 512
    mul  $t7, $t5, 4
    add  $t8, $s0, $t6
    add  $t8, $t8, $t7
    sw   $t9, 0($t8)
    addi $t4, $t4, 1
    j    O_bottom_border_col
O_bottom_border_next:
    addi $t2, $t2, 1
    j    O_bottom_border
O_bottom_border_done:

# -------------------------------------
# Draw left border (2 columns) for middle rows (rows 43 to 52)
li   $t2, 0
O_left_border:
    bge  $t2, 10, O_left_border_done
    addi $t3, $t0, 2
    add  $t3, $t3, $t2
    li   $t4, 0
O_left_border_col:
    bge  $t4, 2, O_left_border_next
    add  $t5, $t1, $t4
    mul  $t6, $t3, 512
    mul  $t7, $t5, 4
    add  $t8, $s0, $t6
    add  $t8, $t8, $t7
    sw   $t9, 0($t8)
    addi $t4, $t4, 1
    j    O_left_border_col
O_left_border_next:
    addi $t2, $t2, 1
    j    O_left_border
O_left_border_done:

# -------------------------------------
# Draw right border (2 columns) for middle rows (rows 43 to 52)
li   $t2, 0
O_right_border:
    bge  $t2, 10, O_right_border_done
    addi $t3, $t0, 2
    add  $t3, $t3, $t2
    li   $t4, 0
O_right_border_col:
    bge  $t4, 2, O_right_border_next
    li   $t5, 8
    add  $t5, $t1, $t5
    add  $t5, $t5, $t4
    mul  $t6, $t3, 512
    mul  $t7, $t5, 4
    add  $t8, $s0, $t6
    add  $t8, $t8, $t7
    sw   $t9, 0($t8)
    addi $t4, $t4, 1
    j    O_right_border_col
O_right_border_next:
    addi $t2, $t2, 1
    j    O_right_border
O_right_border_done:

# ---- Draw V beside the O ----
# Assumes:
#   $s0 holds BASE_ADDRESS
#   $t9 holds white (0x00FFFFFF)
# This V is drawn starting at row 41 with its center at col 55, height = 14 pixels.
# The arms converge to a point at the bottom.
 
    li   $t0, 0          # Row counter (i: 0 to 13 for 14 rows)
    li   $t1, 41         # Base row for V (top row)
    li   $t2, 59         # Center column for V
    li   $t3, 3          # Maximum horizontal offset at the top = 3 pixels
    li   $t7, 13         # Denom for interpolation (height - 1 = 13)
 
V_loop:
    bge  $t0, 14, V_done         # If row counter >= 14, we're done.
    add  $t4, $t1, $t0           # Current row = base row + i
 
    # Compute offset = 3 - (3 * i) / 13
    mul  $t5, $t0, $t3           # t5 = i * 3
    div  $t5, $t7                # Divide by 13; quotient goes to LO
    mflo $t5                    # t5 = (i*3)/13 (integer division)
    sub  $t6, $t3, $t5          # t6 = offset = 3 - (i*3)/13
 
    # Compute left and right pixel columns:
    sub  $t8, $t2, $t6          # left pixel col = center - offset
    add  $s1, $t2, $t6          # s1 = right pixel col = center + offset
 
    # Draw left pixel:
    mul  $s2, $t4, 512          # s2 = current row * 512 (row offset in bytes)
    mul  $s3, $t8, 4            # s3 = left col * 4 (column offset in bytes)
    add  $s4, $s0, $s2          # s4 = BASE_ADDRESS + row offset
    add  $s4, $s4, $s3          # s4 = final pixel address for left pixel
    sw   $t9, 0($s4)            # store white pixel at left location
 
    # Draw right pixel:
    mul  $s3, $s1, 4            # s3 = right col * 4 (reuse s3)
    add  $s4, $s0, $s2          # s4 = BASE_ADDRESS + row offset (reuse s4)
    add  $s4, $s4, $s3          # s4 = final pixel address for right pixel
    sw   $t9, 0($s4)            # store white pixel at right location
 
    addi $t0, $t0, 1            # Increment row counter
    j    V_loop
V_done:


# ---- Draw E beside the V ----
# Base coordinates for E_3
li $t0, 41        # base row
li $t1, 66        # base column (adjust as needed)

# Top horizontal line of E_3 (row 41)
li   $t2, 0
E3_top:
    bge $t2, 7, E3_top_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    E3_top
E3_top_done:

# Left vertical line of E_3 (col = base col)
li   $t2, 0
E3_left:
    bge $t2, 14, E3_left_done
    add  $t3, $t0, $t2
    mul  $t4, $t3, 512
    mul  $t5, $t1, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    E3_left
E3_left_done:

# Middle horizontal line of E_3 (row 48)
li   $t2, 0
li   $t7, 48
E3_mid:
    bge $t2, 6, E3_mid_done
    add  $t3, $t1, $t2
    mul  $t4, $t7, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    E3_mid
E3_mid_done:

# Bottom horizontal line of E_3 (row 54)
li   $t2, 0
li   $t7, 54
E3_bot:
    bge $t2, 7, E3_bot_done
    add  $t3, $t1, $t2
    mul  $t4, $t7, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    E3_bot
E3_bot_done:

# ---- Draw R_2 (moved one pixel down; top starts at row 41, col 75) ----

# Top Horizontal Stroke (row 41)
li   $t0, 41        # base row for top stroke
li   $t1, 75        # base column
li   $t2, 0         # column offset counter
R_top_loop2:
    bge  $t2, 6, R_top_done2
    add  $t3, $t1, $t2         # current col = base col + offset
    mul  $t4, $t0, 512         # row offset in bytes
    mul  $t5, $t3, 4           # column offset in bytes
    add  $t6, $s0, $t4         # BASE_ADDRESS + row offset
    add  $t6, $t6, $t5         # final pixel address
    sw   $t9, 0($t6)           # draw pixel
    addi $t2, $t2, 1
    j    R_top_loop2
R_top_done2:

# Left Vertical Stroke (rows 41 to 52)
li   $t0, 41        # starting row for left vertical stroke
R_left_vert2:
    bgt  $t0, 54, R_left_done2
    mul  $t4, $t0, 512         # row offset
    mul  $t5, $t1, 4           # left column offset (base col remains 75)
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    R_left_vert2
R_left_done2:

# Top Right Vertical Stroke (rows 42 to 45)
li   $t0, 42        # starting row for top right vertical stroke
li   $t7, 81        # right stroke column = base col + 6 (75+6=81)
R_top_right_vert2:
    bgt  $t0, 45, R_top_right_done2
    mul  $t4, $t0, 512
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    R_top_right_vert2
R_top_right_done2:

# Horizontal Cross Stroke (row 46)
li   $t0, 46        # row for cross stroke
li   $t2, 0         # column offset counter
R_cross_loop2:
    bge  $t2, 6, R_cross_done2
    add  $t3, $t1, $t2         # current col = base col + offset
    mul  $t4, $t0, 512         # row offset in bytes
    mul  $t5, $t3, 4           # column offset in bytes
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    R_cross_loop2
R_cross_done2:

# Bottom Vertical Leg (rows 47 to 52)
li   $t0, 47        # starting row for bottom leg
li   $t7, 81        # right column remains 81
R_bottom_leg2:
    bgt  $t0, 54, R_bottom_done2
    mul  $t4, $t0, 512
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    R_bottom_leg2
R_bottom_done2:


        # --- Wait for a key press (stays on screen) ---
wait_key:
        li   $t0, 0xffff0000   # Keyboard MMIO base address
        lw   $t1, 0($t0)       # Read key status
        beq  $t1, $zero, wait_key
        jr   $ra              # Return or halt execution




######################################################################
# INPUT HANDLERS
######################################################################
move_left:
    lw   $t4, player_col
    li   $t5, 2
    ble  $t4, $t5, done_moving   # Prevent moving left if at or below boundary
    addi $t4, $t4, -4            # Subtract 2 units => 2*4 = 8 pixels
    sw   $t4, player_col
    # Set facing to left (1)
    li   $t6, 1
    sw   $t6, player_facing
done_moving:
    lw   $t7, move_delay_value
    sw   $t7, move_delay_counter
    j skip_input

move_right:
    lw   $t4, player_col
    li   $t5, 124
    bge  $t4, $t5, done_moving2  # Prevent moving right if at or beyond boundary
    addi $t4, $t4, 4             # Add 2 units => 2*4 = 8 pixels
    sw   $t4, player_col
    # Set facing to right (0)
    li   $t6, 0
    sw   $t6, player_facing
done_moving2:
    lw   $t7, move_delay_value
    sw   $t7, move_delay_counter
    j skip_input

try_jump:
    la   $t0, is_jumping
    lw   $t1, 0($t0)
    bnez $t1, game_loop
    li   $t1, 1
    sw   $t1, 0($t0)
    la   $t2, player_velocity
    li   $t3, -6
    sw   $t3, 0($t2)
    lw   $t7, move_delay_value
    sw   $t7, move_delay_counter
    j skip_input

######################################################################
# GRAVITY ENGINE (platform is fully solid: no climbing from below)
######################################################################
apply_gravity:
    la   $t0, is_jumping
    lw   $t1, 0($t0)
    la   $t2, player_row
    lw   $t3, 0($t2)       # old player row in $t3
    la   $t4, player_velocity
    lw   $t5, 0($t4)       # current velocity in $t5
    bnez $t1, apply_physics
    li   $t6, 60          # floor: max row = 60
    beq  $t3, $t6, done_gravity
    li   $t1, 1
    sw   $t1, 0($t0)
    li   $t5, 1
    sw   $t5, 0($t4)
    j    apply_physics

apply_physics:
    move $t6, $t3         # save old row in $t6
    add  $t3, $t3, $t5    # new row = old row + velocity

    # For collision checks, compute bottoms:
    addi $t7, $t3, 3      # new_bottom = new row + 3
    addi $t9, $t6, 3      # old_bottom = old row + 3

    # Branch based on velocity:
    bgtz $t5, check_downward         # if falling (velocity > 0)
    bltz $t5, check_upward_A         # if jumping (velocity < 0)
    j no_platform_collision          # if velocity == 0

#---------------- Downward Collision for Platform A (row 50, cols 10–30) ----------------
check_downward:
    slti $s4, $t9, 50          # $s4 = 1 if old_bottom < 50
    slti $s5, $t7, 50          # $s5 = 1 if new_bottom < 50
    beq  $s4, $zero, check_platform_B  # if old_bottom not less than 50, go to next
    bnez $s5, check_platform_B          # if new_bottom still less than 50, no collision with A
    j    check_horizontal_A

check_horizontal_A:
    lw   $s6, player_col      # player's left col
    addi $t8, $s6, 3          # player's right col = left + 3
    li   $s7, 31              # if player's left col >= 31, no collision
    bge  $s6, $s7, check_platform_B
    li   $s7, 10              # platform A left boundary = 10
    blt  $t8, $s7, check_platform_B  # if player's right col < 10, no collision
    # Downward collision detected for Platform A: clamp player's row to 50 - 4 = 46
    li   $t3, 46
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

#---------------- Downward Collision for Platforms B–E ----------------
# (As in your previous code; unchanged from earlier snippet.)
check_platform_B:
    slti $s4, $t9, 40
    slti $s5, $t7, 40
    beq  $s4, $zero, check_platform_C
    bnez $s5, check_platform_C
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 71
    bge  $s6, $s7, check_platform_C
    li   $s7, 40
    blt  $t8, $s7, check_platform_C
    li   $t3, 36
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_platform_C:
    slti $s4, $t9, 30
    slti $s5, $t7, 30
    beq  $s4, $zero, check_platform_D
    bnez $s5, check_platform_D
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 106
    bge  $s6, $s7, check_platform_D
    li   $s7, 80
    blt  $t8, $s7, check_platform_D
    li   $t3, 26
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_platform_D:
    slti $s4, $t9, 25
    slti $s5, $t7, 25
    beq  $s4, $zero, check_platform_E
    bnez $s5, check_platform_E
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 46
    bge  $s6, $s7, check_platform_E
    li   $s7, 20
    blt  $t8, $s7, check_platform_E
    li   $t3, 21
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_platform_E:
    slti $s4, $t9, 45
    slti $s5, $t7, 45
    beq  $s4, $zero, no_platform_collision
    bnez $s5, no_platform_collision
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 121
    bge  $s6, $s7, no_platform_collision
    li   $s7, 95
    blt  $t8, $s7, no_platform_collision
    li   $t3, 41
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

#---------------- Upward Collision Checks for Platforms A–E ----------------
check_upward_A:
    # For upward collision on Platform A (row 50)
    ble  $t6, 50, check_upward_B  # if old top <= 50, no collision here
    bgt  $t3, 50, check_upward_B  # if new top > 50, no collision
    j    check_horizontal_up_A
check_horizontal_up_A:
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 31
    bge  $s6, $s7, check_upward_B
    li   $s7, 10
    blt  $t8, $s7, check_upward_B
    # Upward collision detected for Platform A: clamp player's row to 51
    li   $t3, 51
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_upward_B:
    # For upward collision on Platform B (row 40)
    ble  $t6, 40, check_upward_C
    bgt  $t3, 40, check_upward_C
    j    check_horizontal_up_B
check_horizontal_up_B:
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 71
    bge  $s6, $s7, check_upward_C
    li   $s7, 40
    blt  $t8, $s7, check_upward_C
    # Upward collision detected for Platform B: clamp player's row to 41
    li   $t3, 41
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_upward_C:
    # For upward collision on Platform C (row 30)
    ble  $t6, 30, check_upward_D
    bgt  $t3, 30, check_upward_D
    j    check_horizontal_up_C
check_horizontal_up_C:
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 106
    bge  $s6, $s7, check_upward_D
    li   $s7, 80
    blt  $t8, $s7, check_upward_D
    # Upward collision detected for Platform C: clamp player's row to 31
    li   $t3, 31
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_upward_D:
    # For upward collision on Platform D (row 25)
    ble  $t6, 25, check_upward_E
    bgt  $t3, 25, check_upward_E
    j    check_horizontal_up_D
check_horizontal_up_D:
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 46
    bge  $s6, $s7, check_upward_E
    li   $s7, 20
    blt  $t8, $s7, check_upward_E
    # Upward collision detected for Platform D: clamp player's row to 26
    li   $t3, 26
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_upward_E:
    # For upward collision on Platform E (row 45)
    ble  $t6, 45, no_platform_collision  # if old top <= 45, no upward collision
    bgt  $t3, 45, no_platform_collision  # if new top > 45, no collision
    j    check_horizontal_up_E
check_horizontal_up_E:
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 121
    bge  $s6, $s7, no_platform_collision
    li   $s7, 95
    blt  $t8, $s7, no_platform_collision
    # Upward collision detected for Platform E: clamp player's row to 46
    li   $t3, 46
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

# If no upward collision detected for any platform:
no_platform_collision:
    bgt  $t3, 60, set_floor
    sw   $t3, player_row
    addi $t5, $t5, 1
    sw   $t5, player_velocity

done_gravity:
    jr   $ra

set_floor:
    li   $t3, 60
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    jr   $ra

end:
    j end

erase_heart:
    # Input: $a0 = heart index to erase (0 = leftmost; 3 = far right when starting with 4 hearts)
    # Base coordinates for hearts (as drawn in your code):
    #   Top row: 4
    #   Left col of first heart: 98
    #   Each heart occupies a 4x5 block and is spaced 7 columns apart.
    
    li   $t0, 98         # Base column for the first heart
    li   $t1, 7          # Spacing increment per heart
    mul  $t2, $a0, $t1   # t2 = heart index * 7
    add  $t2, $t0, $t2   # t2 now holds the starting column for the heart to erase

    li   $t3, 4          # Base row for hearts (row 4)
    li   $t7, 0          # Row offset counter (0 .. 3)
erase_heart_row_loop:
    bge  $t7, 4, erase_heart_done  # If row offset >= 4, we're done
    add  $t8, $t3, $t7   # t8 = current row = base row + row offset

    li   $t5, 0          # Column offset counter (0 .. 4)
erase_heart_col_loop:
    bge  $t5, 5, next_heart_row   # If column offset >= 5, move to next row
    add  $t9, $t2, $t5   # t9 = current column = starting col + column offset

    # Compute pixel address:
    #   pixel address = BASE_ADDRESS + (current row * 512) + (current col * 4)
    sll  $a1, $t8, 9     # $a1 = current row * 512  (512 = 2^9)
    sll  $a2, $t9, 2     # $a2 = current col * 4    (4 = 2^2)
    add  $a1, $s0, $a1   # $a1 = BASE_ADDRESS + (row offset)
    add  $a1, $a1, $a2   # $a1 = final pixel address
    lw   $a3, black     # $a3 = black color (0x00000000)
    sw   $a3, 0($a1)    # Overwrite pixel with black

    addi $t5, $t5, 1    # Next column offset
    j    erase_heart_col_loop
next_heart_row:
    addi $t7, $t7, 1    # Next row in the heart block
    j    erase_heart_row_loop
erase_heart_done:
    jr   $ra



########################################################################
# START SCREEN SUBROUTINE
########################################################################
start_screen:
    # Clear the display (64 rows x 128 cols) with dark blue ($s3)
    li   $s0, BASE_ADDRESS    # Ensure $s0 is set to the base address
    li   $s3, 0x00000080      # Dark blue background
    li   $t4, 0               # row counter (0 .. 63)
start_bg_row_loop:
    li   $t5, 0               # col counter (0 .. 127)
start_bg_col_loop:
    mul  $t6, $t4, 512        # compute row offset in bytes
    mul  $t7, $t5, 4          # compute col offset in bytes
    add  $t8, $s0, $t6        # base address + row offset
    add  $t8, $t8, $t7        # + col offset
    sw   $s3, 0($t8)          # set pixel to dark blue
    addi $t5, $t5, 1
    blt  $t5, 128, start_bg_col_loop
    addi $t4, $t4, 1
    blt  $t4, 64, start_bg_row_loop

# "START" title: shifted 15 columns right and 20 rows down (35 down - 15 up = net 20 rows)

# ========== Big "S" ==========
li   $t9, 0x00FFFFFF
li   $t0, 40              # row
li   $t1, 45              # col

li   $t2, 0
S_top_loop:
    bge  $t2, 8, S_top_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    S_top_loop
S_top_done:

li   $t0, 41
S_upper_vert:
    bgt  $t0, 44, S_upper_vert_done
    mul  $t4, $t0, 512
    mul  $t5, $t1, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    S_upper_vert
S_upper_vert_done:

li   $t0, 45
li   $t2, 0
S_mid_loop:
    bge  $t2, 8, S_mid_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    S_mid_loop
S_mid_done:

li   $t0, 46
li   $t1, 52
S_lower_vert:
    bgt  $t0, 50, S_lower_vert_done
    mul  $t4, $t0, 512
    mul  $t5, $t1, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    S_lower_vert
S_lower_vert_done:

li   $t0, 51
li   $t1, 45
li   $t2, 0
S_bottom_loop:
    bge  $t2, 8, S_bottom_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    S_bottom_loop
S_bottom_done:

# ========== Big "T" ==========
li   $t0, 40
li   $t1, 55
li   $t2, 0
T_top_loop:
    bge  $t2, 8, T_top_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    T_top_loop
T_top_done:

li   $t7, 3
add  $t8, $t1, $t7        # center col = 58
li   $t0, 41
T_vert_loop:
    bgt  $t0, 51, T_vert_done
    mul  $t4, $t0, 512
    mul  $t5, $t8, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    T_vert_loop
T_vert_done:

# ========== Big "A" ==========
li   $t0, 40
li   $t1, 65
li   $t2, 0
A_top_loop:
    bge  $t2, 8, A_top_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    A_top_loop
A_top_done:

li   $t0, 41
A_left_vert:
    bgt  $t0, 51, A_left_done
    mul  $t4, $t0, 512
    li   $t7, 65
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    A_left_vert
A_left_done:

li   $t0, 41
A_right_vert:
    bgt  $t0, 51, A_right_done
    mul  $t4, $t0, 512
    li   $t7, 72
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    A_right_vert
A_right_done:

li   $t0, 46
li   $t2, 0
A_cross_loop:
    bge  $t2, 8, A_cross_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    A_cross_loop
A_cross_done:

# ========== Big "R" ==========
li   $t0, 40
li   $t1, 75
li   $t2, 0
R_top_loop:
    bge  $t2, 6, R_top_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    R_top_loop
R_top_done:

li   $t0, 40
R_left_vert:
    bgt  $t0, 51, R_left_done
    mul  $t4, $t0, 512
    mul  $t5, $t1, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    R_left_vert
R_left_done:

li   $t0, 41
li   $t7, 81
R_top_right_vert:
    bgt  $t0, 44, R_top_right_done
    mul  $t4, $t0, 512
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    R_top_right_vert
R_top_right_done:

li   $t0, 45
li   $t2, 0
R_cross_loop:
    bge  $t2, 6, R_cross_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    R_cross_loop
R_cross_done:

li   $t0, 46
li   $t7, 81
R_bottom_leg:
    bgt  $t0, 51, R_bottom_done
    mul  $t4, $t0, 512
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    R_bottom_leg
R_bottom_done:

# ========== Final "T" ==========
li   $t0, 40
li   $t1, 85
li   $t2, 0
T2_top_loop:
    bge  $t2, 8, T2_top_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    T2_top_loop
T2_top_done:

li   $t7, 3
add  $t8, $t1, $t7      # 85 + 3 = 88
li   $t0, 41
T2_vert_loop:
    bgt  $t0, 51, T2_vert_done
    mul  $t4, $t0, 512
    mul  $t5, $t8, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    T2_vert_loop
T2_vert_done:

# Draw white 3D cube at row 15, col 33 (above START and 30 cols right of original)
li $t9, 0x00FFFFFF          # White color

# -----------------------------
# Front face square (15,33)
# -----------------------------
# Top horizontal
li $t0, 15                  # row
li $t1, 33                  # col start
li $t2, 0
CubeFront_top:
    bge $t2, 10, CubeFront_top_done
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j CubeFront_top
CubeFront_top_done:

# Bottom horizontal
li $t0, 24
li $t2, 0
CubeFront_bottom:
    bge $t2, 10, CubeFront_bottom_done
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j CubeFront_bottom
CubeFront_bottom_done:

# Left vertical
li $t0, 15
li $t2, 0
CubeFront_left:
    bge $t2, 10, CubeFront_left_done
    add $t3, $t0, $t2
    mul $t4, $t3, 512
    mul $t5, $t1, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j CubeFront_left
CubeFront_left_done:

# Right vertical
li $t1, 42                 # 33 + 9
li $t0, 15
li $t2, 0
CubeFront_right:
    bge $t2, 10, CubeFront_right_done
    add $t3, $t0, $t2
    mul $t4, $t3, 512
    mul $t5, $t1, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j CubeFront_right
CubeFront_right_done:

# -----------------------------
# Back face square (18,37)
# -----------------------------
li $t0, 18
li $t1, 37
li $t2, 0
CubeBack_top:
    bge $t2, 10, CubeBack_top_done
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j CubeBack_top
CubeBack_top_done:

# Back bottom
li $t0, 27
li $t2, 0
CubeBack_bottom:
    bge $t2, 10, CubeBack_bottom_done
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j CubeBack_bottom
CubeBack_bottom_done:

# Back left vertical
li $t0, 18
li $t2, 0
CubeBack_left:
    bge $t2, 10, CubeBack_left_done
    add $t3, $t0, $t2
    mul $t4, $t3, 512
    li  $t1, 37
    mul $t5, $t1, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j CubeBack_left
CubeBack_left_done:

# Back right vertical
li $t0, 18
li $t2, 0
CubeBack_right:
    bge $t2, 10, CubeBack_right_done
    add $t3, $t0, $t2
    mul $t4, $t3, 512
    li  $t1, 46              # 37 + 9
    mul $t5, $t1, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j CubeBack_right
CubeBack_right_done:

# -----------------------------
# Diagonal 1: top-left (15,33) -> (18,37)
li $t2, 0
CubeDiag1:
    bge $t2, 4, CubeDiag1_done
    addi $t3, $t2, 15
    addi $t4, $t2, 33
    mul  $t5, $t3, 512
    mul  $t6, $t4, 4
    add  $t7, $s0, $t5
    add  $t7, $t7, $t6
    sw   $t9, 0($t7)
    addi $t2, $t2, 1
    j CubeDiag1
CubeDiag1_done:

# Diagonal 2: top-right (15,42) -> (18,46)
li $t2, 0
CubeDiag2:
    bge $t2, 4, CubeDiag2_done
    addi $t3, $t2, 15
    addi $t4, $t2, 42
    mul  $t5, $t3, 512
    mul  $t6, $t4, 4
    add  $t7, $s0, $t5
    add  $t7, $t7, $t6
    sw   $t9, 0($t7)
    addi $t2, $t2, 1
    j CubeDiag2
CubeDiag2_done:

# Diagonal 3: bottom-left (24,33) -> (27,37)
li $t2, 0
CubeDiag3:
    bge $t2, 4, CubeDiag3_done
    addi $t3, $t2, 24
    addi $t4, $t2, 33
    mul  $t5, $t3, 512
    mul  $t6, $t4, 4
    add  $t7, $s0, $t5
    add  $t7, $t7, $t6
    sw   $t9, 0($t7)
    addi $t2, $t2, 1
    j CubeDiag3
CubeDiag3_done:

# Diagonal 4: bottom-right (24,42) -> (27,46)
li $t2, 0
CubeDiag4:
    bge $t2, 4, CubeDiag4_done
    addi $t3, $t2, 24
    addi $t4, $t2, 42
    mul  $t5, $t3, 512
    mul  $t6, $t4, 4
    add  $t7, $s0, $t5
    add  $t7, $t7, $t6
    sw   $t9, 0($t7)
    addi $t2, $t2, 1
    j CubeDiag4
CubeDiag4_done:

# -----------------------------
# Draw W A R S beside the cube starting at row 15, col 50

# ---- Draw W (row 15, col 50) ----
li $t0, 15
li $t1, 50
li $t2, 0
W_left:
    bge $t2, 12, W_left_done
    add $t3, $t0, $t2
    mul $t4, $t3, 512
    mul $t5, $t1, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j W_left
W_left_done:

li $t2, 0
W_right:
    bge $t2, 12, W_right_done
    add $t3, $t0, $t2
    li $t7, 57
    mul $t4, $t3, 512
    mul $t5, $t7, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j W_right
W_right_done:

# W diagonal left-to-center (row 25 to 27, cols 51 to 53)
li $t2, 0
W_diag_left:
    bge $t2, 3, W_diag_left_done
    addi $t3, $t2, 25      # row = 25 + t2
    addi $t4, $t2, 54      # col = 51 + t2
    mul  $t5, $t3, 512
    mul  $t6, $t4, 4
    add  $t7, $s0, $t5
    add  $t7, $t7, $t6
    sw   $t9, 0($t7)
    addi $t2, $t2, 1
    j W_diag_left
W_diag_left_done:

# W diagonal right-to-center (row 25 to 27, cols 56 to 54)
li $t2, 0
W_diag_right:
    bge $t2, 3, W_diag_right_done
    addi $t3, $t2, 25      # row = 25 + t2
    li   $t4, 53
    sub  $t4, $t4, $t2     # col = 56 - t2
    mul  $t5, $t3, 512
    mul  $t6, $t4, 4
    add  $t7, $s0, $t5
    add  $t7, $t7, $t6
    sw   $t9, 0($t7)
    addi $t2, $t2, 1
    j W_diag_right
W_diag_right_done:

# ---- Draw A (row 15, col 60) ----
li $t0, 15
li $t1, 60
li $t2, 0
A_top_loop2:
    bge $t2, 8, A_top_done2
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j A_top_loop2
A_top_done2:

li $t0, 16
A_left_vert2:
    bgt $t0, 26, A_left_done2
    mul $t4, $t0, 512
    li $t7, 60
    mul $t5, $t7, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t0, $t0, 1
    j A_left_vert2
A_left_done2:

li $t0, 16
A_right_vert2:
    bgt $t0, 26, A_right_done2
    mul $t4, $t0, 512
    li $t7, 67
    mul $t5, $t7, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t0, $t0, 1
    j A_right_vert2
A_right_done2:

li $t0, 21
li $t2, 0
A_cross2:
    bge $t2, 8, A_cross_done2
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j A_cross2
A_cross_done2:

# ---- Draw R (row 15, col 70) ----
li   $t0, 15
li   $t1, 70
li   $t2, 0
R_top_loop1:
    bge  $t2, 6, R_top_done1
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    R_top_loop1
R_top_done1:

li   $t0, 15
R_left_vert1:
    bgt  $t0, 26, R_left_done1
    mul  $t4, $t0, 512
    mul  $t5, $t1, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    R_left_vert1
R_left_done1:

li   $t0, 16
li   $t7, 76
R_top_right_vert1:
    bgt  $t0, 19, R_top_right_done1
    mul  $t4, $t0, 512
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    R_top_right_vert1
R_top_right_done1:

li   $t0, 20
li   $t2, 0
R_cross_loop1:
    bge  $t2, 6, R_cross_done1
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    R_cross_loop1
R_cross_done1:

li   $t0, 21
li   $t7, 76
R_bottom_leg1:
    bgt  $t0, 26, R_bottom_done1
    mul  $t4, $t0, 512
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    R_bottom_leg1
R_bottom_done1:

# ---- Draw S (row 15, col 80) ----
li $t0, 15
li $t1, 80
li $t2, 0
S_top1:
    bge $t2, 8, S_top_done1
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j S_top1
S_top_done1:

# Upper vertical (left side)
li $t0, 16
S_upper_vert1:
    bgt $t0, 19, S_upper_vert_done1
    mul $t4, $t0, 512
    mul $t5, $t1, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t0, $t0, 1
    j S_upper_vert1
S_upper_vert_done1:

# Middle horizontal
li $t0, 20
li $t2, 0
S_mid1:
    bge $t2, 8, S_mid_done1
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j S_mid1
S_mid_done1:

# Lower vertical (right side)
li $t0, 21
li $t7, 87
S_lower_vert1:
    bgt $t0, 24, S_lower_vert_done1
    mul $t4, $t0, 512
    mul $t5, $t7, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t0, $t0, 1
    j S_lower_vert1
S_lower_vert_done1:

# Bottom horizontal
li $t0, 25
li $t1, 80
li $t2, 0
S_bottom1:
    bge $t2, 8, S_bottom_done1
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j S_bottom1
S_bottom_done1:


start_input_loop:
    li   $t0, 0xffff0000      # Keyboard MMIO base address
wait_for_key:
    lw   $t1, 0($t0)          # Read key status
    beq  $t1, $zero, wait_for_key  # No key pressed, wait
    lw   $t2, 4($t0)          # Read ASCII code of key pressed
    li   $t3, 115             # ASCII for 's'
    beq  $t2, $t3, start_game  # If 's' pressed, start the game
    li   $t3, 113             # ASCII for 'q'
    beq  $t2, $t3, restart_start_screen  # If 'q' pressed, restart the screen
    j wait_for_key            # For any other key, keep waiting

start_game:
    jr $ra                    # Return to caller (main continues to main_game_loop)

restart_start_screen:
    # Clear key buffer
    li   $t0, 0xffff0000
clear_key_buffer:
    lw   $t1, 0($t0)          # Read key status
    beq  $t1, $zero, restart_start_screen_continue
    lw   $t2, 4($t0)          # Read ASCII code to clear buffer
    j    clear_key_buffer

restart_start_screen_continue:
    jal start_screen
    j start_input_loop
