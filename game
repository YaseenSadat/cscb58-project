#####################################################################
#
# CSCB58 Winter 2025 Assembly Final Project
# University of Toronto, Scarborough
#
# Student: Yaseen Sadat, 1010358596, sadatyas, yaseen.sadat@mail.utoronto.ca
#
# Bitmap Display Configuration:
# - Unit width in pixels: 4
# - Unit height in pixels: 4
# - Display width in pixels: 256
# - Display height in pixels: 256
# - Base Address for Display: 0x10008000 ($gp)
#
# Which milestones have been reached in this submission?
# - Milestone 1
#
# Which approved features have been implemented for milestone 3?
# 1. (None yet â€“ coming soon!)
#
# Link to video demonstration for final submission:
# - (Coming soon!)
#
# Are you OK with us sharing the video with people outside course staff?
# - yes
#
# Any additional information that the TA needs to know:
# - Step-by-step build in progress
#
#####################################################################

.eqv BASE_ADDRESS 0x10008000    # Framebuffer base address in memory

.data
# Stores the player's vertical and horizontal positions
player_row: .word 60            # Y-position (row)
player_col: .word 2             # X-position (column)

# Jumping physics variables
player_velocity: .word 0        # Y velocity (positive = falling, negative = jumping up)
is_jumping: .word 0             # 1 if in the air (jumping or falling), 0 if grounded

.text
main:
    ################################################################
    # INITIALIZE CONSTANTS
    # s0 = framebuffer base, s1 = platform color, s2 = player color,
    # s3 = background color
    ################################################################
    li $s0, BASE_ADDRESS        # Base address of the display
    li $s1, 0x00808080          # Grey color for platforms
    li $s2, 0x00FF0000          # Red color for player
    li $s3, 0x00000000          # Black for background/erasing

    ################################################################
    # DRAW STATIC PLATFORMS (floor + 2 floating)
    ################################################################
    li $t4, 63                  # Floor row
    li $t5, 0
floor_loop:
    mul $t6, $t4, 512
    mul $t7, $t5, 4
    add $t8, $s0, $t6
    add $t8, $t8, $t7
    sw $s1, 0($t8)              # Draw floor pixel
    addi $t5, $t5, 1
    blt $t5, 128, floor_loop

    # Platform 1 (row 40, cols 20-40)
    li $t4, 40
    li $t5, 20
plat1_loop:
    mul $t6, $t4, 512
    mul $t7, $t5, 4
    add $t8, $s0, $t6
    add $t8, $t8, $t7
    sw $s1, 0($t8)
    addi $t5, $t5, 1
    blt $t5, 41, plat1_loop

    # Platform 2 (row 30, cols 70-100)
    li $t4, 30
    li $t5, 70
plat2_loop:
    mul $t6, $t4, 512
    mul $t7, $t5, 4
    add $t8, $s0, $t6
    add $t8, $t8, $t7
    sw $s1, 0($t8)
    addi $t5, $t5, 1
    blt $t5, 101, plat2_loop

    ################################################################
    # INIT previous player position for erase logic
    ################################################################
    li $s6, 60    # prev_row
    li $s7, 2     # prev_col

######################################################################
# MAIN GAME LOOP
# Handles input, erases previous player, applies gravity,
# draws updated position, and waits for next frame
######################################################################
game_loop:
        ################################################################
    # 1) Handle Continuous Input If a Key Is Held Down
    ################################################################
    li $t0, 0xffff0000          # MMIO base
    lw $t1, 0($t0)              # Check if a key is being held (1 = yes)
    bne $t1, 1, skip_input      # If no key, skip input handling

    lw $t2, 4($t0)              # Get ASCII of the key

    li $t3, 97                  # 'a'
    beq $t2, $t3, move_left

    li $t3, 100                 # 'd'
    beq $t2, $t3, move_right

    li $t3, 119                 # 'w'
    beq $t2, $t3, try_jump

skip_input:



no_input:
    ################################################################
    # 2) Erase Previous Player Position
    ################################################################
    li $t8, 0
erase_loop_rows:
    li $t9, 0
erase_loop_cols:
    add $t4, $s6, $t8
    add $t5, $s7, $t9
    mul $t6, $t4, 512
    mul $t7, $t5, 4
    add $t7, $t7, $t6
    add $t7, $s0, $t7
    sw $s3, 0($t7)
    addi $t9, $t9, 1
    blt $t9, 3, erase_loop_cols
    addi $t8, $t8, 1
    blt $t8, 3, erase_loop_rows

    ################################################################
    # 3) Apply Gravity (updates row based on jump/fall)
    ################################################################
    jal apply_gravity

    ################################################################
    # 4) Load and Clamp Player Position from Memory
    ################################################################
    la $t0, player_row
    la $t1, player_col
    lw $t4, 0($t0)            # row
    lw $t5, 0($t1)            # col

    li $t6, 0
    blt $t5, $t6, fix_left
    li $t6, 125
    bgt $t5, $t6, fix_right
    j skip_col_clamp

fix_left:
    li $t5, 0
    sw $t5, 0($t1)
    j skip_col_clamp

fix_right:
    li $t5, 125
    sw $t5, 0($t1)

skip_col_clamp:
    lw $t5, 0($t1)            # reload clamped value

    ################################################################
    # 5) Draw 3x3 Player Block at New Position
    ################################################################
    li $t8, 0
draw_loop_rows:
    li $t9, 0
draw_loop_cols:
    add $t6, $t4, $t8
    add $t7, $t5, $t9
    mul $t6, $t6, 512
    mul $t7, $t7, 4
    add $t6, $t6, $t7
    add $t6, $s0, $t6
    sw $s2, 0($t6)
    addi $t9, $t9, 1
    blt $t9, 3, draw_loop_cols
    addi $t8, $t8, 1
    blt $t8, 3, draw_loop_rows

    ################################################################
    # 6) Save Current Position as Previous for Next Frame
    ################################################################
    move $s6, $t4
    move $s7, $t5

    ################################################################
    # 7) Frame Delay
    ################################################################
    li $v0, 32
    li $a0, 40
    syscall

    j game_loop

######################################################################
# INPUT HANDLERS
######################################################################
move_left:
    lw $t4, player_col
    li $t5, 2
    ble $t4, $t5, done_moving
    addi $t4, $t4, -1
    sw $t4, player_col
done_moving:
    j skip_input

move_right:
    lw $t4, player_col
    li $t5, 125
    bge $t4, $t5, done_moving2
    addi $t4, $t4, 1
    sw $t4, player_col
done_moving2:
    j skip_input

try_jump:
    la $t0, is_jumping
    lw $t1, 0($t0)
    bnez $t1, game_loop         # skip if already jumping/falling
    li $t1, 1
    sw $t1, 0($t0)
    la $t2, player_velocity
    li $t3, -5                  # jump force (negative Y velocity)
    sw $t3, 0($t2)
    j skip_input

######################################################################
# GRAVITY & JUMP PHYSICS ENGINE
######################################################################
apply_gravity:
    la $t0, is_jumping
    lw $t1, 0($t0)
    la $t2, player_row
    lw $t3, 0($t2)
    la $t4, player_velocity
    lw $t5, 0($t4)
    bnez $t1, apply_physics
    li $t6, 63
    beq $t3, $t6, done_gravity
    li $t1, 1
    sw $t1, 0($t0)
    li $t5, 1
    sw $t5, 0($t4)
    j apply_physics

apply_physics:
    add $t3, $t3, $t5
    bgt $t3, 63, set_floor
    sw $t3, 0($t2)
    addi $t5, $t5, 1
    sw $t5, 0($t4)
    j done_gravity

set_floor:
    li $t3, 63
    sw $t3, 0($t2)
    li $t5, 0
    sw $t5, 0($t4)
    li $t1, 0
    sw $t1, 0($t0)
    j done_gravity

done_gravity:
    jr $ra

######################################################################
# SAFEGUARD HALT (fallback loop)
######################################################################
end:
    j end
