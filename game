#####################################################################
#
# CSCB58 Winter 2025 Assembly Final Project
# University of Toronto, Scarborough
#
# Student: Yaseen Sadat, 1010358596, sadatyas, yaseen.sadat@mail.utoronto.ca
#
# Bitmap Display Configuration:
# - Unit width in pixels: 4
# - Unit height in pixels: 4
# - Display width in pixels: 512
# - Display height in pixels: 256
# - Base Address for Display: 0x10008000 ($gp)
#
# Milestones reached:
# - Milestone 1
#
# Approved features for Milestone 3:
# 1. Player now has a 4x4 sprite with eyes that differ based on facing:
#    - Right facing (player_facing==0): eyes at (row1, col1) and (row1, col3)
#    - Left facing  (player_facing==1): eyes at (row1, col0) and (row1, col2)
#
# 2. Floating Platform Collision (one-way):
#    - Platform A (row 50, cols 10 to 30) now collides with the player only when
#      falling from above. If the player's bottom (player_row+3) goes from above row 50
#      to row 50 or below and the player horizontally overlaps the platform,
#      the player is set to stand on the platform (player_row = 46).
#
# Additional information:
# - Step-by-step build in progress
#
#####################################################################
.eqv BASE_ADDRESS 0x10008000    # Framebuffer base address

.data
################################################################
# PLAYER STATE & MOVEMENT VARIABLES
################################################################
player_row:         .word 60        # Player Y-position (row)
player_col:         .word 2         # Player X-position (column)
player_velocity:    .word 0         # Vertical velocity (positive = falling, negative = jumping)
is_jumping:         .word 0         # 1 = player is in air, 0 = on ground
player_facing:      .word 0         # 0 = facing right, 1 = facing left

current_player_row: .word 0         # Temporary row position
current_player_col: .word 0         # Temporary column position

player_bg_buffer:   .space 64       # Buffer for 4×4 player background (16 words = 64 bytes)

move_delay_counter: .word 0         # Frame countdown to delay movement
move_delay_value:   .word 2         # Movement delay constant (affects speed)

################################################################
# ENEMY DATA (up to 3 enemies)
################################################################
enemy_row:          .word 20        # Enemy 1 row position
enemy_col:          .word 0         # Enemy 1 column start
enemy_velocity:     .word 2         # Enemy 1 speed (pixels/frame)
enemy_bg_buffer:    .space 64       # Buffer for 4x4 enemy 1 sprite

enemy2_row:         .word 45        # Enemy 2 row
enemy2_col:         .word 0         # Enemy 2 column
enemy2_velocity:    .word 2         # Enemy 2 speed
enemy2_bg_buffer:   .space 64       # Buffer for 4x4 enemy 2 sprite

enemy3_row:         .word 35        # Enemy 3 row
enemy3_col:         .word 0         # Enemy 3 column
enemy3_velocity:    .word 2         # Enemy 3 speed
enemy3_bg_buffer:   .space 64       # Buffer for 4x4 enemy 3 sprite

################################################################
# COIN DATA
################################################################
coin_pattern_6x7:                 # 6×7 coin bitmap (used for drawing)
    .half 0x50, 0x154, 0x5A5, 0x595, 0x5A5, 0x154, 0x50

coin_counter:       .word 0        # Number of coins collected

coin_collected:     .word 0        # Coin 1: 0 = not collected, 1 = collected
coin_row:           .word 30       # Coin 1 row
coin_col:           .word 50       # Coin 1 column

coin2_row:          .word 17       # Coin 2 row
coin2_col:          .word 30       # Coin 2 column
coin2_collected:    .word 0        # Coin 2: 0 = not collected, 1 = collected

coin3_row:          .word 20       # Coin 3 row
coin3_col:          .word 90       # Coin 3 column
coin3_collected:    .word 0        # Coin 3: 0 = not collected, 1 = collected

coin4_row:          .word 37       # Coin 4 row
coin4_col:          .word 105      # Coin 4 column
coin4_collected:    .word 0        # Coin 4: 0 = not collected, 1 = collected

################################################################
# COLOR DEFINITIONS
################################################################
# Red planet palette (top-left area)
darkest_red:   .word 0x008B0000     # Dark red
dark_red:      .word 0x00B22222     # Firebrick
mid_red:       .word 0x00CD5C5C     # IndianRed
light_red:     .word 0x00FA8072     # Salmon

black:         .word 0x00000000     # Black (used for facial features or backgrounds)

################################################################
# PLAYER HEALTH & DAMAGE STATE
################################################################
hearts:                .word 4      # Player health (4 hearts)
enemy_collision_count: .word 0      # Number of times player has collided with enemies

double_jump_used: .word 0
mid_air_jump_count: .word 0
double_jump_available: .word 3

damage_cooldown: .word 0            # > 0 = temporary invulnerability active
damage_delay:    .word 50           # Duration of cooldown in frames (~2 seconds)


################################################################
# PLATFORM STATE
################################################################

platform_d_left:      .word 20      # current left column (initially 20)
platform_d_prev_left: .word 20      # previous left column (initially 20)
platform_d_velocity:  .word 1       # horizontal velocity (initially 1)
platform_d_bg_buffer: .space 104    # background buffer for Platform D (26 pixels * 4 bytes)

################################################################
# EARTH PLANET COLORS (top-right visual theme)
################################################################
# These define a multi-shade palette for Earth-like visuals
earth_dark:    .word 0x00004080     # Dark ocean blue (R=0, G=64, B=128)
earth_ocean:   .word 0x000080FF     # Bright ocean (R=0, G=128, B=255)
earth_land:    .word 0x00008000     # Land green (R=0, G=128, B=0)
earth_clouds:  .word 0x00FFFFFF     # Clouds (white)

################################################################
# MAIN GAME ENTRY
################################################################
.text
main:
    ################################################################
    # START SCREEN
    ################################################################
    jal start_screen               # Call start screen subroutine

main_game_loop:
    ################################################################
    # INITIALIZE CONSTANT COLORS AND ADDRESSES
    ################################################################
    li   $s0, BASE_ADDRESS         # Load framebuffer base address
    li   $s1, 0x00808080           # Platform color (grey)
    li   $s2, 0x00FF0000           # Player color (red)
    li   $s3, 0x00000080           # Background color (dark blue)

    ################################################################
    # DRAW BACKGROUND (64 rows × 128 columns)
    ################################################################
    li   $t4, 0                    # Start row = 0
bg_row_loop:
    li   $t5, 0                    # Start column = 0
bg_col_loop:
    mul  $t6, $t4, 512             # Calculate row offset (512 bytes/row)
    mul  $t7, $t5, 4               # Calculate column offset (4 bytes/pixel)
    add  $t8, $s0, $t6             # base + row offset
    add  $t8, $t8, $t7             # base + row + column offset
    sw   $s3, 0($t8)               # Set pixel to dark blue
    addi $t5, $t5, 1               # Next column
    blt  $t5, 128, bg_col_loop     # Loop until column < 128
    addi $t4, $t4, 1               # Next row
    blt  $t4, 64, bg_row_loop      # Loop until row < 64

################################################################
# DRAW STARS (Each row has its own position and spacing)
################################################################

# Row 1
li $s4, 4                         # Fixed Y-position (row) for stars
li $s5, 4                         # Start column for this row
li $t8, 20                        # Spacing between stars
jal draw_star_row

# Row 2
li $s4, 20
li $s5, 10
li $t8, 15
jal draw_star_row

# Row 3
li $s4, 36
li $s5, 2
li $t8, 20
jal draw_star_row

# Row 4
li $s4, 52
li $s5, 8
li $t8, 18
jal draw_star_row

j stars_done                      # Jump past draw_star_row definitions

################################################################
# Subroutine: draw_star_row
# Draws a row of plus-shaped stars
# $s4 = fixed row position
# $s5 = starting column
# $t8 = gap between stars
################################################################
draw_star_row:
    li $t0, 124              # Maximum column value
    move $t7, $s5            # Current column for star placement

next_star:
    bgt $t7, $t0, end_star_row   # Exit if past screen width
    li  $t9, 0x00FFFF00          # Star color (yellow)

    # Draw vertical line (3 pixels tall, centered)
    li   $t1, 0
draw_v:
    bgt  $t1, 2, done_v
    add  $t2, $s4, $t1            # Row = base row + offset
    addi $t3, $t7, 1              # Col = center of plus
    mul  $t4, $t2, 512            # Row offset
    mul  $t5, $t3, 4              # Column offset
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)              # Store yellow pixel
    addi $t1, $t1, 1
    j draw_v
done_v:

    # Draw horizontal line (3 pixels wide, centered)
    li $t1, 0
draw_h:
    bgt  $t1, 2, done_h
    addi $t2, $s4, 1              # Fixed center row
    add  $t3, $t7, $t1            # Col = base col + offset
    mul  $t4, $t2, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t1, $t1, 1
    j draw_h
done_h:

    add $t7, $t7, $t8             # Move to next star column
    j next_star

end_star_row:
    jr $ra

stars_done:

################################################################
# DRAW BLACK RECTANGLE (Top-right, rows 3–9, cols 95–126)
################################################################
li   $t0, 3                      # Start row
black_rect_row_loop:
    li   $t1, 95                 # Start column
black_rect_col_loop:
    mul  $t2, $t0, 512           # Row offset
    mul  $t3, $t1, 4             # Column offset
    add  $t4, $s0, $t2
    add  $t4, $t4, $t3
    li   $t5, 0x00000000         # Color: black
    sw   $t5, 0($t4)             # Draw black pixel
    addi $t1, $t1, 1
    blt  $t1, 127, black_rect_col_loop
    addi $t0, $t0, 1
    ble  $t0, 9, black_rect_row_loop

################################################################
# DRAW WHITE BORDER AROUND RECTANGLE (1 pixel wider on all sides)
################################################################
li   $t5, 0x00FFFFFF             # White color
li   $t0, 2                      # Start row (1 above black rect)
white_border_row_loop:
    li   $t1, 94                 # Start col (1 left of black rect)
white_border_col_loop:
    # Define edge conditions
    li   $t6, 2                  # Top row
    li   $t7, 10                 # Bottom row
    li   $t8, 94                 # Left col
    li   $t9, 126                # Right col
    beq  $t0, $t6, draw_white_border
    beq  $t0, $t7, draw_white_border
    beq  $t1, $t8, draw_white_border
    beq  $t1, $t9, draw_white_border
    j skip_white_border

draw_white_border:
    mul  $s1, $t0, 512
    mul  $s2, $t1, 4
    add  $s3, $s0, $s1
    add  $s3, $s3, $s2
    sw   $t5, 0($s3)

skip_white_border:
    addi $t1, $t1, 1
    ble  $t1, 126, white_border_col_loop
    addi $t0, $t0, 1
    ble  $t0, 10, white_border_row_loop

################################################################
# DRAW SECOND BLACK RECTANGLE (Left side, rows 3–13, cols 5–36)
################################################################
li   $t0, 3
black_rect2_row_loop:
    li   $t1, 5
black_rect2_col_loop:
    mul  $t2, $t0, 512
    mul  $t3, $t1, 4
    add  $t4, $s0, $t2
    add  $t4, $t4, $t3
    li   $t5, 0x00000000
    sw   $t5, 0($t4)
    addi $t1, $t1, 1
    blt  $t1, 37, black_rect2_col_loop
    addi $t0, $t0, 1
    ble  $t0, 13, black_rect2_row_loop

################################################################
# DRAW WHITE BORDER AROUND SECOND RECTANGLE (1 pixel buffer)
################################################################
li   $t5, 0x00FFFFFF
li   $t0, 2                      # Start row (1 above rect)
white_border2_row_loop:
    li   $t1, 4                  # Start col (1 left of rect)
white_border2_col_loop:
    li   $t6, 2                  # Top
    li   $t7, 13                 # Bottom
    li   $t8, 4                  # Left
    li   $t9, 37                 # Right
    beq  $t0, $t6, draw_white_border2
    beq  $t0, $t7, draw_white_border2
    beq  $t1, $t8, draw_white_border2
    beq  $t1, $t9, draw_white_border2
    j skip_white_border2

draw_white_border2:
    mul  $s1, $t0, 512
    mul  $s2, $t1, 4
    add  $s3, $s0, $s1
    add  $s3, $s3, $s2
    sw   $t5, 0($s3)

skip_white_border2:
    addi $t1, $t1, 1
    ble  $t1, 37, white_border2_col_loop
    addi $t0, $t0, 1
    ble  $t0, 13, white_border2_row_loop

################################################################
# DRAW HEARTS (Top-right corner, 4 red heart icons)
################################################################
li   $t0, 0x00FF0000             # Heart color (red)
li   $t1, 4                      # Starting row
li   $t2, 98                     # Starting column
li   $t3, 4                      # Number of hearts

heart_loop:
    beq  $t3, $zero, hearts_done

    # Heart Row 0: R R _ R R
    li $t4, 0
    li $t5, 0
heart_row0:
    bge $t5, 5, heart_row0_done
    li  $t6, 1
    beq $t5, 2, skip_pixel0
    j draw_pixel0
skip_pixel0:
    li $t6, 0
draw_pixel0:
    beq $t6, $zero, next_col0
    add $t7, $t2, $t5
    add $t8, $t1, $t4
    mul $t9, $t8, 512
    mul $s1, $t7, 4
    add $s2, $s0, $t9
    add $s2, $s2, $s1
    sw  $t0, 0($s2)
next_col0:
    addi $t5, $t5, 1
    j heart_row0
heart_row0_done:

    # Heart Row 1: R R R R R
    li $t4, 1
    li $t5, 0
heart_row1:
    bge $t5, 5, heart_row1_done
    add $t7, $t2, $t5
    add $t8, $t1, $t4
    mul $t9, $t8, 512
    mul $s1, $t7, 4
    add $s2, $s0, $t9
    add $s2, $s2, $s1
    sw  $t0, 0($s2)
    addi $t5, $t5, 1
    j heart_row1
heart_row1_done:

    # Heart Row 2: _ R R R _
    li $t4, 2
    li $t5, 0
heart_row2:
    bge $t5, 5, heart_row2_done
    li  $t6, 0
    bgt $t5, 0, check_col2
    j next_col2
check_col2:
    blt $t5, 4, set_draw2
    j next_col2
set_draw2:
    li $t6, 1
next_col2:
    beq $t6, $zero, skip_pixel2
    add $t7, $t2, $t5
    add $t8, $t1, $t4
    mul $t9, $t8, 512
    mul $s1, $t7, 4
    add $s2, $s0, $t9
    add $s2, $s2, $s1
    sw  $t0, 0($s2)
skip_pixel2:
    addi $t5, $t5, 1
    j heart_row2
heart_row2_done:

    # Heart Row 3: _ _ R _ _
    li $t4, 3
    addi $t7, $t2, 2
    add $t8, $t1, $t4
    mul  $t9, $t8, 512
    mul  $s1, $t7, 4
    add  $s2, $s0, $t9
    add  $s2, $s2, $s1
    sw   $t0, 0($s2)

    # Move to next heart (7 pixels apart)
    addi $t2, $t2, 7
    addi $t3, $t3, -1
    j heart_loop

hearts_done:


 ################################################################
# DRAW RED PLANET (Top-left corner, swirl pattern)
################################################################
li   $t0, 15         # Base row for red planet
li   $t1, 5          # Base column for red planet
li   $t2, 24         # Planet bounding box (24x24)
li   $t3, 12         # Radius = 12
addu $t8, $t1, $t3   # center_col = base_col + radius
addu $t9, $t0, $t3   # center_row = base_row + radius
li   $t4, 0          # Outer loop counter (row index)

planet_row_loop:
    bge  $t4, $t2, planet_done
    addu $t6, $t0, $t4         # current_row = base_row + i
    li   $t5, 0                # Inner loop counter (col index)

planet_col_loop:
    bge  $t5, $t2, planet_next_row
    addu $t7, $t1, $t5         # current_col = base_col + j
    sub  $a0, $t7, $t8         # dx = col - center_col
    sub  $a1, $t6, $t9         # dy = row - center_row
    mul  $v1, $a0, $a0         # dx^2
    mul  $t3, $a1, $a1         # dy^2
    addu $v1, $v1, $t3         # distance^2 = dx^2 + dy^2
    li   $t3, 144              # radius^2 = 12^2
    bgt  $v1, $t3, planet_skip_pixel  # Skip if outside circle

    # Swirl pattern (2*dy + dx) >> 2 mod 4
    sll  $v0, $a1, 1
    addu $v0, $v0, $a0
    sra  $v0, $v0, 2
    andi $v0, $v0, 3

    # Select shade of red based on pattern
    li   $t3, 0
    beq  $v0, $zero, pick_darkest
    li   $t3, 1
    beq  $v0, $t3, pick_dark
    li   $t3, 2
    beq  $v0, $t3, pick_mid

pick_light:
    lw   $t3, light_red
    j    planet_set_pixel
pick_mid:
    lw   $t3, mid_red
    j    planet_set_pixel
pick_dark:
    lw   $t3, dark_red
    j    planet_set_pixel
pick_darkest:
    lw   $t3, darkest_red

planet_set_pixel:
    mul  $v1, $t6, 512
    sll  $a0, $t7, 2
    addu $v1, $s0, $v1
    addu $v1, $v1, $a0
    sw   $t3, 0($v1)           # Draw selected red shade

planet_skip_pixel:
    addi $t5, $t5, 1
    j    planet_col_loop

planet_next_row:
    addi $t4, $t4, 1
    j    planet_row_loop

planet_done:

################################################################
# DRAW EARTH-LIKE PLANET (Top-right corner, swirl pattern)
################################################################
li   $t0, 12         # Base row for Earth
li   $t1, 102        # Base column for Earth
li   $t2, 24         # Bounding box (24x24)
li   $t3, 12         # Radius = 12
addu $t8, $t1, $t3   # center_col
addu $t9, $t0, $t3   # center_row
li   $t4, 0          # Row loop counter

earth_row_loop:
    bge  $t4, $t2, earth_done
    addu $t6, $t0, $t4         # current_row
    li   $t5, 0                # Column loop counter

earth_col_loop:
    bge  $t5, $t2, earth_next_row
    addu $t7, $t1, $t5         # current_col
    sub  $a0, $t7, $t8         # dx
    sub  $a1, $t6, $t9         # dy
    mul  $v1, $a0, $a0         # dx^2
    mul  $t3, $a1, $a1         # dy^2
    addu $v1, $v1, $t3         # distance^2
    li   $t3, 144              # radius^2
    bgt  $v1, $t3, earth_skip_pixel

    # Swirl pattern
    sll  $v0, $a1, 1
    addu $v0, $v0, $a0
    sra  $v0, $v0, 2
    andi $v0, $v0, 3

    # Choose Earth color based on pattern value
    li   $t3, 0
    beq  $v0, $zero, pick_earth_dark
    li   $t3, 1
    beq  $v0, $t3, pick_earth_ocean
    li   $t3, 2
    beq  $v0, $t3, pick_earth_land

pick_earth_clouds:
    lw   $t3, earth_clouds
    j    earth_set_pixel
pick_earth_land:
    lw   $t3, earth_land
    j    earth_set_pixel
pick_earth_ocean:
    lw   $t3, earth_ocean
    j    earth_set_pixel
pick_earth_dark:
    lw   $t3, earth_dark

earth_set_pixel:
    mul  $v1, $t6, 512
    sll  $a0, $t7, 2
    addu $v1, $s0, $v1
    addu $v1, $v1, $a0
    sw   $t3, 0($v1)

earth_skip_pixel:
    addi $t5, $t5, 1
    j    earth_col_loop

earth_next_row:
    addi $t4, $t4, 1
    j    earth_row_loop

earth_done:

################################################################
# DRAW PLATFORMS A–E (floating grey blocks)
################################################################
li $t9, 0x00808080           # Grey platform color

# Platform A: row 50, cols 10–30
li $t4, 50
li $t5, 10
platA_loop:
    mul $t6, $t4, 512
    mul $t7, $t5, 4
    add $t8, $s0, $t6
    add $t8, $t8, $t7
    sw  $t9, 0($t8)
    addi $t5, $t5, 1
    blt  $t5, 31, platA_loop

# Platform B: row 40, cols 40–70
li $t4, 40
li $t5, 40
platB_loop:
    mul $t6, $t4, 512
    mul $t7, $t5, 4
    add $t8, $s0, $t6
    add $t8, $t8, $t7
    sw  $t9, 0($t8)
    addi $t5, $t5, 1
    blt  $t5, 71, platB_loop

# Platform C: row 30, cols 80–105
li $t4, 30
li $t5, 80
platC_loop:
    mul $t6, $t4, 512
    mul $t7, $t5, 4
    add $t8, $s0, $t6
    add $t8, $t8, $t7
    sw  $t9, 0($t8)
    addi $t5, $t5, 1
    blt  $t5, 106, platC_loop

# Platform D: row 25, cols 20–45
li $t4, 25
li $t5, 20
platD_loop:
    mul $t6, $t4, 512
    mul $t7, $t5, 4
    add $t8, $s0, $t6
    add $t8, $t8, $t7
    sw  $t9, 0($t8)
    addi $t5, $t5, 1
    blt  $t5, 46, platD_loop

# Platform E: row 45, cols 95–120
li $t4, 45
li $t5, 95
platE_loop:
    mul $t6, $t4, 512
    mul $t7, $t5, 4
    add $t8, $s0, $t6
    add $t8, $t8, $t7
    sw  $t9, 0($t8)
    addi $t5, $t5, 1
    blt  $t5, 121, platE_loop

################################################################
# DRAW COINS (8x8 sprites using draw_gold_coin_new)
################################################################
li $a0, 32      # Coin 1 top row
li $a1, 50      # Coin 1 left col
jal draw_gold_coin_new

li $a0, 17      # Coin 2 top row
li $a1, 30      # Coin 2 left col
jal draw_gold_coin_new

li $a0, 22      # Coin 3 top row
li $a1, 90      # Coin 3 left col
jal draw_gold_coin_new

li $a0, 37      # Coin 4 top row
li $a1, 105     # Coin 4 left col
jal draw_gold_coin_new

################################################################
# INIT PREVIOUS PLAYER POSITION
################################################################
li   $s6, 60     # Initial player row
li   $s7, 2      # Initial player column

######################################################################
# MAIN GAME LOOP
######################################################################
game_loop:


################################################################
# 1) Handle Continuous Input with Delay
################################################################
li   $t0, 0xffff0000         # Keyboard MMIO base
lw   $t1, 0($t0)             # Read key status
beq  $t1, $zero, reset_delay # No key pressed: reset delay counter

lw   $t2, move_delay_counter # Load movement delay counter
bnez $t2, decrement_delay    # If not zero, skip input processing

# A key is pressed and delay counter is zero
lw   $t3, 4($t0)             # Read ASCII key code
li   $t4, 97                 # 'a'
beq  $t3, $t4, move_left
li   $t4, 100                # 'd'
beq  $t3, $t4, move_right
li   $t4, 119                # 'w'
beq  $t3, $t4, try_jump

go_to_start_screen:
jal  start_screen            # Go to start screen
# After returning from start screen, reset game state:
li   $t0, 60
sw   $t0, player_row
li   $t0, 2
sw   $t0, player_col
li   $t0, 0
sw   $t0, player_velocity
sw   $t0, is_jumping
j    game_loop

decrement_delay:
lw   $t2, move_delay_counter
addi $t2, $t2, -1
sw   $t2, move_delay_counter

reset_delay:
li   $t2, 0
sw   $t2, move_delay_counter
j    skip_input

################################################################
# 2) Restore Old Player Background from Buffer (4x4 pixels)
################################################################
skip_input:
la   $t3, player_bg_buffer
li   $t8, 0
restore_bg_loop_rows:
    li   $t9, 0
restore_bg_loop_cols:
    add  $t4, $s6, $t8
    add  $t5, $s7, $t9
    mul  $t4, $t4, 512
    mul  $t5, $t5, 4
    add  $t0, $s0, $t4
    add  $t0, $t0, $t5
    lw   $t1, 0($t3)
    sw   $t1, 0($t0)
    addi $t3, $t3, 4
    addi $t9, $t9, 1
    blt  $t9, 4, restore_bg_loop_cols
    addi $t8, $t8, 1
    blt  $t8, 4, restore_bg_loop_rows

################################################################
# 3) Apply Gravity to Player
################################################################
jal apply_gravity

################################################################
# 4) Clamp & Save New Player Position
################################################################
la   $t0, player_row
la   $t1, player_col
lw   $t4, 0($t0)
lw   $t5, 0($t1)

# Clamp row between 0 and 60
li   $t6, 0
blt  $t4, $t6, fix_top
li   $t6, 60
bgt  $t4, $t6, fix_bottom
j    skip_row_clamp
fix_top:
li   $t4, 0
sw   $t4, player_row
j    skip_row_clamp
fix_bottom:
li   $t4, 60
sw   $t4, player_row
skip_row_clamp:

# Clamp col between 0 and 124
li   $t6, 0
blt  $t5, $t6, fix_left
li   $t6, 124
bgt  $t5, $t6, fix_right
j    skip_col_clamp
fix_left:
li   $t5, 0
sw   $t5, player_col
j    skip_col_clamp
fix_right:
li   $t5, 124
sw   $t5, player_col
skip_col_clamp:

# Save new position to current_* variables
lw   $t5, 0($t1)
la   $t7, current_player_row
sw   $t4, 0($t7)
la   $t7, current_player_col
sw   $t5, 0($t7)

################################################################
# 5) Save New Background into Buffer (4x4)
################################################################
la   $t3, player_bg_buffer
li   $t8, 0
save_bg_loop_rows:
    la   $t7, current_player_row
    lw   $t5, 0($t7)
    la   $t7, current_player_col
    lw   $t6, 0($t7)
    li   $t9, 0
save_bg_loop_cols:
    add  $t2, $t5, $t8
    add  $t1, $t6, $t9
    mul  $t2, $t2, 512
    mul  $t1, $t1, 4
    add  $t0, $s0, $t2
    add  $t0, $t0, $t1
    lw   $t4, 0($t0)
    sw   $t4, 0($t3)
    addi $t3, $t3, 4
    addi $t9, $t9, 1
    blt  $t9, 4, save_bg_loop_cols
    addi $t8, $t8, 1
    blt  $t8, 4, save_bg_loop_rows



###### Platform D Movement with Background Restoration and Oscillation ######
# This code does the following:
# 1. Restores the background from the previous frame (using a buffer).
# 2. Updates Platform D’s horizontal position so that it oscillates between
#    left bound (col 20) and right bound (col 64, i.e., halfway across the screen).
# 3. Saves the new background from the updated location into the buffer.
# 4. Draws Platform D (a 1-row, 26-pixel-wide platform in white: 0x00FFFFFF)
#    at row 25.
# 5. Updates the previous position variable for the next frame.

# --- 1. Restore Background for Previous Platform D Position ---
    la   $t0, platform_d_bg_buffer   # pointer to saved background buffer
    la   $t1, platform_d_prev_left   # pointer to previous left column value
    lw   $t2, 0($t1)                 # previous left column
    li   $t3, 25                     # fixed row for Platform D (row 25)
    li   $t4, 0                      # column index counter (0 to 25)
    li   $t5, 26                     # platform width (26 pixels)
restore_platD_bg_loop:
    add  $t6, $t2, $t4              # current column = prev_left + index
    mul  $t7, $t3, 512              # row offset = row * 512 bytes
    mul  $t6, $t6, 4                # column offset = (current column * 4 bytes)
    add  $t7, $s0, $t7              # BASE_ADDRESS + row offset
    add  $t7, $t7, $t6              # final pixel address for restoration
    lw   $t8, 0($t0)               # load saved background pixel from buffer
    sw   $t8, 0($t7)               # restore that pixel onto the framebuffer
    addi $t0, $t0, 4               # advance buffer pointer (4 bytes per pixel)
    addi $t4, $t4, 1               # next pixel index
    blt  $t4, $t5, restore_platD_bg_loop

# --- 2. Update Platform D's Horizontal Position (Oscillation) ---
    la   $t0, platform_d_left       # load address of current left column
    lw   $t1, 0($t0)                # current left column value in $t1
    la   $t2, platform_d_velocity   # load address of velocity variable
    lw   $t3, 0($t2)                # load current velocity in $t3
    add  $t1, $t1, $t3              # new left column = old left + velocity
    li   $t4, 20                    # left boundary (col 20)
    li   $t5, 45                    # right boundary (halfway across the screen)
    bgt  $t1, $t5, reverse_right    # if new left col > right bound, reverse direction
    blt  $t1, $t4, reverse_left     # if new left col < left bound, reverse direction
    sw   $t1, 0($t0)                # store new left column value
    j    update_velocity_done
reverse_right:
    li   $t6, -1                    # reverse velocity: now move left
    sw   $t6, 0($t2)                # update velocity in memory
    move $t1, $t5                  # set new left col to right boundary
    sw   $t1, 0($t0)
    j    update_velocity_done
reverse_left:
    li   $t6, 1                     # reverse velocity: now move right
    sw   $t6, 0($t2)                # update velocity in memory
    move $t1, $t4                  # set new left col to left boundary
    sw   $t1, 0($t0)
update_velocity_done:

# --- 3. Save New Background for Platform D ---
    la   $t0, platform_d_bg_buffer   # reset pointer to background buffer start
    la   $t1, platform_d_left        # load new left column pointer
    lw   $t2, 0($t1)                # new left column for Platform D
    li   $t3, 25                    # fixed row for Platform D
    li   $t4, 0                     # column index counter (0 to 25)
    li   $t5, 26                    # platform width (26 pixels)
save_platD_bg_loop:
    add  $t6, $t2, $t4              # current column = new left + index
    mul  $t7, $t3, 512              # row offset = row * 512
    mul  $t6, $t6, 4                # column offset = current column * 4 bytes
    add  $t7, $s0, $t7              # BASE_ADDRESS + row offset
    add  $t7, $t7, $t6              # final pixel address to read from
    lw   $t8, 0($t7)                # read the background pixel from the framebuffer
    sw   $t8, 0($t0)                # save it into the background buffer
    addi $t0, $t0, 4               # advance buffer pointer
    addi $t4, $t4, 1               # next pixel index
    blt  $t4, $t5, save_platD_bg_loop

# --- 4. Draw Platform D at New Position ---
    li   $t3, 25                    # fixed row for Platform D (row 25)
    la   $t0, platform_d_left       # load new left column pointer
    lw   $t1, 0($t0)                # new left column value
    li   $t4, 0                     # drawing column index counter (0 to 25)
    li   $t5, 26                    # platform width (26 pixels)
    li   $t6, 0x00FFFFFF            # platform color (white)
draw_platD_loop:
    mul  $t7, $t3, 512              # compute row offset = 25 * 512
    add  $t8, $t1, $t4              # current column = new left + index
    mul  $t8, $t8, 4                # compute column offset in bytes
    add  $t9, $s0, $t7              # BASE_ADDRESS + row offset
    add  $t9, $t9, $t8              # final pixel address for drawing
    sw   $t6, 0($t9)               # draw platform pixel (white)
    addi $t4, $t4, 1               # increment drawing index
    blt  $t4, $t5, draw_platD_loop

# --- 5. Update Previous Position for Next Frame ---
    la   $t0, platform_d_prev_left
    la   $t1, platform_d_left
    lw   $t2, 0($t1)
    sw   $t2, 0($t0)



################################################################
# 6) Draw Player Sprite at New Position
################################################################
li   $t8, 0
draw_loop_rows:
    la   $t7, current_player_row
    lw   $t5, 0($t7)
    la   $t7, current_player_col
    lw   $t6, 0($t7)
    li   $t9, 0
draw_loop_cols:
    add  $t2, $t5, $t8
    add  $t1, $t6, $t9
    mul  $t2, $t2, 512
    mul  $t1, $t1, 4
    add  $t0, $s0, $t2
    add  $t0, $t0, $t1

    # Draw eyes if on row 1, else draw red
    li   $t3, 1
    bne  $t8, $t3, player_set_red
    lw   $t3, player_facing
    beq  $t3, $zero, right_facing

    # Left-facing eyes
left_facing:
    li   $t4, 0
    beq  $t9, $t4, player_set_black
    li   $t4, 2
    beq  $t9, $t4, player_set_black
    j    player_set_red

# Right-facing eyes
right_facing:
    li   $t4, 1
    beq  $t9, $t4, player_set_black
    li   $t4, 3
    beq  $t9, $t4, player_set_black
    j    player_set_red

player_set_black:
    lw   $t7, black
    j    store_pixel
player_set_red:
    move $t7, $s2
store_pixel:
    sw   $t7, 0($t0)

    addi $t9, $t9, 1
    blt  $t9, 4, draw_loop_cols
    addi $t8, $t8, 1
    blt  $t8, 4, draw_loop_rows

################################################################
# 7) Update Previous Player Position
################################################################
la   $t7, current_player_row
lw   $t4, 0($t7)
move $s6, $t4
la   $t7, current_player_col
lw   $t4, 0($t7)
move $s7, $t4

################################################################
# 7.1) Restore Old Enemy Background (from enemy_bg_buffer)
################################################################
la   $t0, enemy_bg_buffer
li   $t1, 0
enemy_restore_bg_loop_rows:
    li   $t2, 0
enemy_restore_bg_loop_cols:
    la   $t3, enemy_row
    lw   $t4, 0($t3)
    add  $t4, $t4, $t1
    la   $t5, enemy_col
    lw   $t6, 0($t5)
    add  $t6, $t6, $t2
    mul  $t4, $t4, 512
    mul  $t6, $t6, 4
    add  $t7, $s0, $t4
    add  $t7, $t7, $t6
    lw   $t8, 0($t0)
    sw   $t8, 0($t7)
    addi $t0, $t0, 4
    addi $t2, $t2, 1
    blt  $t2, 4, enemy_restore_bg_loop_cols
    li   $t2, 0
    addi $t1, $t1, 1
    blt  $t1, 4, enemy_restore_bg_loop_rows

################################################################
# 7.2) Update Enemy Position (Horizontal movement & wrap)
################################################################
la   $t0, enemy_col
lw   $t1, 0($t0)
la   $t2, enemy_velocity
lw   $t3, 0($t2)
add  $t1, $t1, $t3
li   $t4, 124
ble  $t1, $t4, enemy_update_done
li   $t1, 0
enemy_update_done:
sw   $t1, 0($t0)

################################################################
# 7.3) Save New Enemy Background (4x4) into enemy_bg_buffer
################################################################
la   $t0, enemy_bg_buffer
li   $t1, 0
enemy_save_bg_loop_rows:
    li   $t2, 0
enemy_save_bg_loop_cols:
    la   $t3, enemy_row
    lw   $t4, 0($t3)
    add  $t4, $t4, $t1
    la   $t5, enemy_col
    lw   $t6, 0($t5)
    add  $t6, $t6, $t2
    mul  $t4, $t4, 512
    mul  $t6, $t6, 4
    add  $t7, $s0, $t4
    add  $t7, $t7, $t6
    lw   $t8, 0($t7)
    sw   $t8, 0($t0)
    addi $t0, $t0, 4
    addi $t2, $t2, 1
    blt  $t2, 4, enemy_save_bg_loop_cols
    addi $t1, $t1, 1
    blt  $t1, 4, enemy_save_bg_loop_rows


    ################################################################
    # 7.4) Draw Enemy Sprite (4×4 green block with black eyes)
    ################################################################
    # Load enemy base positions.
    la   $t0, enemy_row         # pointer to enemy_row
    lw   $t1, 0($t0)            # enemy's base row -> $t1
    la   $t0, enemy_col         # pointer to enemy_col (reuse $t0)
    lw   $t2, 0($t0)            # enemy's base col -> $t2

    # Load color constants.
    li   $t7, 0x00008000        # green color for enemy body (in $t7)
    li   $t8, 0x00000000        # black color for eyes (in $t8)

    # Set up constant registers (using saved registers $s4 and $s5).
    addi $s4, $zero, 1         # $s4 = 1
    addi $s5, $zero, 3         # $s5 = 3

    # Initialize row offset in $t3.
    addi $t3, $zero, 0         # row offset = 0
enemy_draw_loop_rows:
    bge  $t3, 4, enemy_draw_done_rows  # if row offset >= 4, exit loop

    # Initialize column offset in $t4.
    addi $t4, $zero, 0         # column offset = 0
enemy_draw_loop_cols:
    bge  $t4, 4, enemy_next_row   # if column offset >= 4, move to next row

    # Compute current pixel's absolute address:
    add  $t9, $t1, $t3        # current row = enemy base row ($t1) + row offset ($t3)
    mul  $t9, $t9, 512        # multiply by 512 to get byte offset for the row
    add  $t5, $t2, $t4        # current col = enemy base col ($t2) + col offset ($t4)
    mul  $t5, $t5, 4          # multiply by 4 to get byte offset for the column
    add  $t6, $s0, $t9        # $s0 is the framebuffer base; add row offset
    add  $t6, $t6, $t5        # add column offset to get final pixel address

    # For the enemy's second row (relative row 1) we want black eyes at col offset 1 and 3.
    beq  $t3, $s4, enemy_eye_row_check  # if row offset equals 1, branch to eye check
    # Otherwise, draw green.
    sw   $t7, 0($t6)
    j    enemy_next_pixel_label

enemy_eye_row_check:
    # Check if the current column offset equals 1 or equals 3.
    beq  $t4, $s4, enemy_draw_black   # if col offset equals 1, draw black
    beq  $t4, $s5, enemy_draw_black   # if col offset equals 3, draw black
    # Otherwise, draw green.
    sw   $t7, 0($t6)
    j    enemy_next_pixel_label

enemy_draw_black:
    sw   $t8, 0($t6)         # draw black pixel for an eye

enemy_next_pixel_label:
    addi $t4, $t4, 1         # increment column offset
    j    enemy_draw_loop_cols

enemy_next_row:
    addi $t3, $t3, 1         # increment row offset
    j    enemy_draw_loop_rows

enemy_draw_done_rows:

    ################################################################
    # --- Enemy2: Restore Old Background from enemy2_bg_buffer (4x4) ---
    ################################################################
    la   $t0, enemy2_bg_buffer    # pointer to enemy2 background buffer
    li   $t1, 0                   # row offset index (0..3)
enemy2_restore_bg_loop_rows:
    li   $t2, 0                   # column offset index (0..3)
enemy2_restore_bg_loop_cols:
    la   $t3, enemy2_row          # load enemy2_row address
    lw   $t4, 0($t3)              # enemy2's base row
    add  $t4, $t4, $t1            # current row = enemy2_row + row offset
    la   $t5, enemy2_col          # load enemy2_col address
    lw   $t6, 0($t5)              # enemy2's base col
    add  $t6, $t6, $t2            # current col = enemy2_col + col offset
    mul  $t4, $t4, 512            # row offset (bytes)
    mul  $t6, $t6, 4              # col offset (bytes)
    add  $t7, $s0, $t4            # base address + row offset
    add  $t7, $t7, $t6            # final pixel address for enemy2 region
    lw   $t8, 0($t0)              # get stored pixel from enemy2_bg_buffer
    sw   $t8, 0($t7)              # restore that pixel into the framebuffer
    addi $t0, $t0, 4              # advance enemy2_bg_buffer pointer
    addi $t2, $t2, 1
    blt  $t2, 4, enemy2_restore_bg_loop_cols
    li   $t2, 0                  # reset col offset for next row
    addi $t1, $t1, 1
    blt  $t1, 4, enemy2_restore_bg_loop_rows

    ################################################################
    # --- Enemy2: Update Position (Horizontal movement) ---
    ################################################################
    la   $t0, enemy2_col          # load enemy2_col address
    lw   $t1, 0($t0)              # get current enemy2 col
    la   $t2, enemy2_velocity     # load enemy2_velocity address
    lw   $t3, 0($t2)              # get enemy2 horizontal speed
    add  $t1, $t1, $t3            # new enemy2 col = old + velocity
    li   $t4, 124                # right boundary (for 4x4 sprite)
    ble  $t1, $t4, enemy2_update_done
    li   $t1, 0                  # if beyond boundary, wrap to left
enemy2_update_done:
    sw   $t1, 0($t0)             # store updated enemy2 col

    ################################################################
    # --- Enemy2: Save New Background into enemy2_bg_buffer (4x4) ---
    ################################################################
    la   $t0, enemy2_bg_buffer    # reset pointer for enemy2 background buffer
    li   $t1, 0                  # row offset index (0..3)
enemy2_save_bg_loop_rows:
    li   $t2, 0                  # column offset index (0..3)
enemy2_save_bg_loop_cols:
    la   $t3, enemy2_row          # load enemy2_row address
    lw   $t4, 0($t3)              # enemy2's base row
    add  $t4, $t4, $t1            # current row = enemy2_row + row offset
    la   $t5, enemy2_col          # load enemy2_col address
    lw   $t6, 0($t5)              # enemy2's base col
    add  $t6, $t6, $t2            # current col = enemy2_col + col offset
    mul  $t4, $t4, 512            # row offset (bytes)
    mul  $t6, $t6, 4              # col offset (bytes)
    add  $t7, $s0, $t4            # base address + row offset
    add  $t7, $t7, $t6            # final pixel address in framebuffer
    lw   $t8, 0($t7)              # read current pixel from framebuffer
    sw   $t8, 0($t0)              # save pixel into enemy2_bg_buffer
    addi $t0, $t0, 4              # advance enemy2_bg_buffer pointer
    addi $t2, $t2, 1
    blt  $t2, 4, enemy2_save_bg_loop_cols
    addi $t1, $t1, 1
    blt  $t1, 4, enemy2_save_bg_loop_rows

    ################################################################
    # --- Enemy2: Draw Sprite (4x4 green block with black eyes) ---
    ################################################################
    # Load enemy2 base positions.
    la   $t0, enemy2_row          # pointer to enemy2_row
    lw   $t1, 0($t0)              # enemy2's base row -> $t1
    la   $t0, enemy2_col          # pointer to enemy2_col
    lw   $t2, 0($t0)              # enemy2's base col -> $t2

    # Load color constants.
    li   $t7, 0x00008000         # green color for enemy2 body
    li   $t8, 0x00000000         # black color for eyes

    # Set up constant registers (reuse $s4 and $s5 as before)
    addi $s4, $zero, 1           # $s4 = 1
    addi $s5, $zero, 3           # $s5 = 3

    # Initialize row offset in $t3.
    addi $t3, $zero, 0           # row offset = 0
enemy2_draw_loop_rows:
    bge  $t3, 4, enemy2_draw_done_rows  # if row offset >= 4, exit loop

    # Initialize column offset in $t4.
    addi $t4, $zero, 0           # column offset = 0
enemy2_draw_loop_cols:
    bge  $t4, 4, enemy2_next_row   # if column offset >= 4, move to next row

    # Compute current pixel's absolute address:
    add  $t9, $t1, $t3           # current row = enemy2 base row ($t1) + row offset ($t3)
    mul  $t9, $t9, 512           # multiply by 512 to get byte offset for the row
    add  $t5, $t2, $t4           # current col = enemy2 base col ($t2) + col offset ($t4)
    mul  $t5, $t5, 4             # multiply by 4 to get byte offset for the column
    add  $t6, $s0, $t9           # add row offset to BASE_ADDRESS
    add  $t6, $t6, $t5           # add column offset to get final pixel address

    # For enemy2’s second row (row offset 1) draw black eyes at col offsets 1 and 3.
    beq  $t3, $s4, enemy2_eye_row_check  # if row offset equals 1, check for eyes
    sw   $t7, 0($t6)             # otherwise, draw green
    j    enemy2_next_pixel_label

enemy2_eye_row_check:
    beq  $t4, $s4, enemy2_draw_black   # if col offset equals 1, draw black
    beq  $t4, $s5, enemy2_draw_black   # if col offset equals 3, draw black
    sw   $t7, 0($t6)             # otherwise, draw green
    j    enemy2_next_pixel_label

enemy2_draw_black:
    sw   $t8, 0($t6)             # draw black pixel for eye

enemy2_next_pixel_label:
    addi $t4, $t4, 1             # increment column offset
    j    enemy2_draw_loop_cols

enemy2_next_row:
    addi $t3, $t3, 1             # increment row offset
    j    enemy2_draw_loop_rows

enemy2_draw_done_rows:


    ################################################################
    # --- Enemy3: Restore Old Background from enemy3_bg_buffer (4x4) ---
    ################################################################
    la   $t0, enemy3_bg_buffer    # pointer to enemy3 background buffer
    li   $t1, 0                   # row offset index (0..3)
enemy3_restore_bg_loop_rows:
    li   $t2, 0                   # column offset index (0..3)
enemy3_restore_bg_loop_cols:
    la   $t3, enemy3_row          # load enemy3_row address
    lw   $t4, 0($t3)              # enemy3's base row
    add  $t4, $t4, $t1            # current row = enemy3_row + row offset
    la   $t5, enemy3_col          # load enemy3_col address
    lw   $t6, 0($t5)              # enemy3's base col
    add  $t6, $t6, $t2            # current col = enemy3_col + col offset
    mul  $t4, $t4, 512            # row offset (bytes)
    mul  $t6, $t6, 4              # col offset (bytes)
    add  $t7, $s0, $t4            # base address + row offset
    add  $t7, $t7, $t6            # final pixel address for enemy3 region
    lw   $t8, 0($t0)              # get stored pixel from enemy3_bg_buffer
    sw   $t8, 0($t7)              # restore that pixel into the framebuffer
    addi $t0, $t0, 4              # advance enemy3_bg_buffer pointer
    addi $t2, $t2, 1
    blt  $t2, 4, enemy3_restore_bg_loop_cols
    li   $t2, 0                   # reset col offset for next row
    addi $t1, $t1, 1
    blt  $t1, 4, enemy3_restore_bg_loop_rows

    ################################################################
    # --- Enemy3: Update Position (Horizontal movement) ---
    ################################################################
    la   $t0, enemy3_col          # load enemy3_col address
    lw   $t1, 0($t0)              # get current enemy3 col
    la   $t2, enemy3_velocity     # load enemy3_velocity address
    lw   $t3, 0($t2)              # get enemy3 horizontal speed
    add  $t1, $t1, $t3            # new enemy3 col = old + velocity
    li   $t4, 124                # right boundary (for 4x4 sprite)
    ble  $t1, $t4, enemy3_update_done
    li   $t1, 0                  # if beyond boundary, wrap to left
enemy3_update_done:
    sw   $t1, 0($t0)             # store updated enemy3 col

    ################################################################
    # --- Enemy3: Save New Background into enemy3_bg_buffer (4x4) ---
    ################################################################
    la   $t0, enemy3_bg_buffer    # reset pointer for enemy3 background buffer
    li   $t1, 0                   # row offset index (0..3)
enemy3_save_bg_loop_rows:
    li   $t2, 0                   # column offset index (0..3)
enemy3_save_bg_loop_cols:
    la   $t3, enemy3_row          # load enemy3_row address
    lw   $t4, 0($t3)              # enemy3's base row
    add  $t4, $t4, $t1            # current row = enemy3_row + row offset
    la   $t5, enemy3_col          # load enemy3_col address
    lw   $t6, 0($t5)              # enemy3's base col
    add  $t6, $t6, $t2            # current col = enemy3_col + col offset
    mul  $t4, $t4, 512            # row offset (bytes)
    mul  $t6, $t6, 4              # col offset (bytes)
    add  $t7, $s0, $t4            # base address + row offset
    add  $t7, $t7, $t6            # final pixel address in framebuffer
    lw   $t8, 0($t7)              # read current pixel from framebuffer
    sw   $t8, 0($t0)              # save pixel into enemy3_bg_buffer
    addi $t0, $t0, 4              # advance enemy3_bg_buffer pointer
    addi $t2, $t2, 1
    blt  $t2, 4, enemy3_save_bg_loop_cols
    addi $t1, $t1, 1
    blt  $t1, 4, enemy3_save_bg_loop_rows

    ################################################################
    # --- Enemy3: Draw Sprite (4x4 green block with black eyes) ---
    ################################################################
    # Load enemy3 base positions.
    la   $t0, enemy3_row          # pointer to enemy3_row
    lw   $t1, 0($t0)              # enemy3's base row -> $t1
    la   $t0, enemy3_col          # pointer to enemy3_col
    lw   $t2, 0($t0)              # enemy3's base col -> $t2

    # Load color constants.
    li   $t7, 0x00008000         # green color for enemy3 body
    li   $t8, 0x00000000         # black color for eyes

    # Set up constant registers (reuse $s4 and $s5 as before)
    addi $s4, $zero, 1           # $s4 = 1
    addi $s5, $zero, 3           # $s5 = 3

    # Initialize row offset in $t3.
    addi $t3, $zero, 0           # row offset = 0
enemy3_draw_loop_rows:
    bge  $t3, 4, enemy3_draw_done_rows  # if row offset >= 4, exit loop

    # Initialize column offset in $t4.
    addi $t4, $zero, 0           # column offset = 0
enemy3_draw_loop_cols:
    bge  $t4, 4, enemy3_next_row   # if column offset >= 4, move to next row

    # Compute current pixel's absolute address:
    add  $t9, $t1, $t3           # current row = enemy3 base row ($t1) + row offset ($t3)
    mul  $t9, $t9, 512           # multiply by 512 to get byte offset for the row
    add  $t5, $t2, $t4           # current col = enemy3 base col ($t2) + col offset ($t4)
    mul  $t5, $t5, 4             # multiply by 4 to get byte offset for the column
    add  $t6, $s0, $t9           # add row offset to BASE_ADDRESS
    add  $t6, $t6, $t5           # add column offset to get final pixel address

    # For enemy3’s second row (row offset 1) draw black eyes at col offsets 1 and 3.
    beq  $t3, $s4, enemy3_eye_row_check  # if row offset equals 1, check for eyes
    sw   $t7, 0($t6)             # otherwise, draw green
    j    enemy3_next_pixel_label

enemy3_eye_row_check:
    beq  $t4, $s4, enemy3_draw_black   # if col offset equals 1, draw black
    beq  $t4, $s5, enemy3_draw_black   # if col offset equals 3, draw black
    sw   $t7, 0($t6)             # otherwise, draw green
    j    enemy3_next_pixel_label

enemy3_draw_black:
    sw   $t8, 0($t6)             # draw black pixel for eye

enemy3_next_pixel_label:
    addi $t4, $t4, 1             # increment column offset
    j    enemy3_draw_loop_cols

enemy3_next_row:
    addi $t3, $t3, 1             # increment row offset
    j    enemy3_draw_loop_rows

enemy3_draw_done_rows:

      ################################################################
    # Collision Check: Player vs. Enemy1
    ################################################################
    # Load player's top-left coordinates.
    la   $t0, player_row      # pointer to player_row
    lw   $t1, 0($t0)          # player's top row
    la   $t2, player_col      # pointer to player_col
    lw   $t3, 0($t2)          # player's left col

    # Load enemy1's top-left coordinates.
    la   $t4, enemy_row       # pointer to enemy1's row
    lw   $t5, 0($t4)          # enemy1's top row
    la   $t6, enemy_col       # pointer to enemy1's col
    lw   $t7, 0($t6)          # enemy1's left col

    # Check enemy1 collision.
    addi $t8, $t1, 3          # player's bottom row
    blt  $t8, $t5, check_enemy2_collision  # if player's bottom < enemy1's top, go check enemy2
    addi $t8, $t5, 3          # enemy1's bottom row
    bgt  $t1, $t8, check_enemy2_collision  # if player's top > enemy1's bottom, go check enemy2
    addi $t8, $t3, 3          # player's right col
    blt  $t8, $t7, check_enemy2_collision  # if player's right < enemy1's left, go check enemy2
    addi $t8, $t7, 3          # enemy1's right col
    bgt  $t3, $t8, check_enemy2_collision  # if player's left > enemy1's right, go check enemy2

    # --- Collision with enemy1 detected ---
    # Check damage cooldown.
    la   $t8, damage_cooldown
    lw   $t9, 0($t8)
    bnez $t9, enemy1_damage_active

    # No cooldown active: Apply damage.
    la   $t0, hearts
    lw   $t1, 0($t0)
    addi $t1, $t1, -1
    sw   $t1, 0($t0)
    blez $t1, game_over
    move $a0, $t1
    jal  erase_heart
    li   $t2, 50
    la   $t8, damage_cooldown
    sw   $t2, 0($t8)
    # Reset collision counter.
    la   $t8, enemy_collision_count
    li   $t9, 0
    sw   $t9, 0($t8)
    j    continue_game

enemy1_damage_active:
    la   $t8, enemy_collision_count
    lw   $t9, 0($t8)
    addi $t9, $t9, 1
    sw   $t9, 0($t8)
    li   $t0, 4
    beq  $t9, $t0, enemy_collision_reset
    j    continue_game

    ################################################################
    # Check Enemy2 Collision if enemy1 is clear.
    ################################################################
check_enemy2_collision:
    # Reload player's coordinates.
    la   $t0, player_row
    lw   $t1, 0($t0)
    la   $t2, player_col
    lw   $t3, 0($t2)
    # Load enemy2's top-left coordinates.
    la   $t4, enemy2_row
    lw   $t5, 0($t4)
    la   $t6, enemy2_col
    lw   $t7, 0($t6)

    # Check enemy2 collision.
    addi $t8, $t1, 3          # player's bottom row
    blt  $t8, $t5, check_enemy3_collision  # if player's bottom < enemy2's top, check enemy3
    addi $t8, $t5, 3          # enemy2's bottom row
    bgt  $t1, $t8, check_enemy3_collision  # if player's top > enemy2's bottom, check enemy3
    addi $t8, $t3, 3          # player's right col
    blt  $t8, $t7, check_enemy3_collision  # if player's right < enemy2's left, check enemy3
    addi $t8, $t7, 3          # enemy2's right col
    bgt  $t3, $t8, check_enemy3_collision  # if player's left > enemy2's right, check enemy3

    # --- Collision with enemy2 detected ---
    # Check damage cooldown.
    la   $t8, damage_cooldown
    lw   $t9, 0($t8)
    bnez $t9, enemy2_damage_active

    # No cooldown active: Apply damage.
    la   $t0, hearts
    lw   $t1, 0($t0)
    addi $t1, $t1, -1
    sw   $t1, 0($t0)
    blez $t1, game_over
    move $a0, $t1
    jal  erase_heart
    li   $t2, 50
    la   $t8, damage_cooldown
    sw   $t2, 0($t8)
    # Reset collision counter.
    la   $t8, enemy_collision_count
    li   $t9, 0
    sw   $t9, 0($t8)
    j    continue_game

enemy2_damage_active:
    la   $t8, enemy_collision_count
    lw   $t9, 0($t8)
    addi $t9, $t9, 1
    sw   $t9, 0($t8)
    li   $t0, 4
    beq  $t9, $t0, enemy_collision_reset
    j    continue_game

################################################################
    # Check Enemy3 Collision
    ################################################################
check_enemy3_collision:
    # Reload player's coords into $t1 (row), $t3 (col)
    la   $t0, player_row
    lw   $t1, 0($t0)
    la   $t2, player_col
    lw   $t3, 0($t2)

    # Load enemy3's top-left into $t5 (row), $t7 (col)
    la   $t4, enemy3_row
    lw   $t5, 0($t4)
    la   $t6, enemy3_col
    lw   $t7, 0($t6)

    # Check bounding-box
    addi $t8, $t1, 3          # player's bottom row
    blt  $t8, $t5, check_coin_collision
    addi $t8, $t5, 3          # enemy3 bottom row
    bgt  $t1, $t8, check_coin_collision
    addi $t8, $t3, 3          # player's right col
    blt  $t8, $t7, check_coin_collision
    addi $t8, $t7, 3          # enemy3 right col
    bgt  $t3, $t8, check_coin_collision

    # --- Collision with enemy3 detected ---
    # Check damage cooldown.
    la   $t8, damage_cooldown
    lw   $t9, 0($t8)
    bnez $t9, enemy3_damage_active

    # No cooldown active: Apply damage.
    la   $t0, hearts
    lw   $t1, 0($t0)
    addi $t1, $t1, -1
    sw   $t1, 0($t0)
    blez $t1, game_over
    move $a0, $t1
    jal  erase_heart
    li   $t2, 50
    la   $t8, damage_cooldown
    sw   $t2, 0($t8)
    # Reset collision counter.
    la   $t8, enemy_collision_count
    li   $t9, 0
    sw   $t9, 0($t8)
    j    continue_game

enemy3_damage_active:
    la   $t8, enemy_collision_count
    lw   $t9, 0($t8)
    addi $t9, $t9, 1
    sw   $t9, 0($t8)
    li   $t0, 4
    beq  $t9, $t0, enemy_collision_reset
    j    continue_game

################################################################
# Coin 1 Collision (6×7 coin)
################################################################
check_coin_collision:
    # (1) Skip if coin1 already collected
    la   $t9, coin_collected
    lw   $t8, 0($t9)
    bnez $t8, check_coin2_collision    # go check coin2 if coin1 is already collected

    # (2) Load player bounding box (assumed 3×3)
    la   $t0, player_row
    lw   $t1, 0($t0)       # player's top row
    la   $t2, player_col
    lw   $t3, 0($t2)       # player's left column

    # (3) Load coin1 bounding box (6×7 coin)
    la   $t4, coin_row
    lw   $t5, 0($t4)       # coin1's top row
    la   $t6, coin_col
    lw   $t7, 0($t6)       # coin1's left column

    # (4) AABB test for coin1
    addi $t8, $t1, 3
    blt  $t8, $t5, check_coin2_collision
    addi $t8, $t5, 7
    bgt  $t1, $t8, check_coin2_collision
    addi $t8, $t3, 3
    blt  $t8, $t7, check_coin2_collision
    addi $t8, $t7, 6
    bgt  $t3, $t8, check_coin2_collision

    # --- Collision with coin1 detected ---
    la   $t9, coin_counter
    lw   $t8, 0($t9)
    addi $t8, $t8, 1
    sw   $t8, 0($t9)
    li   $t0, 4
    beq  $t8, $t0, win_screen
    la   $t9, coin_collected
    li   $t8, 1
    sw   $t8, 0($t9)
    # Draw new coin1 at new position (row 5, col 6)
    li   $a0, 5
    li   $a1, 6
    jal  draw_gold_coin_new
    j    continue_game

################################################################
# Coin 2 Collision (6×7 coin)
################################################################
check_coin2_collision:
    # (1) Skip if coin2 already collected
    la   $t9, coin2_collected
    lw   $t8, 0($t9)
    bnez $t8, check_coin3_collision   # branch to coin3 if already collected

    # (2) Load player bounding box (assumed 3×3)
    la   $t0, player_row
    lw   $t1, 0($t0)
    la   $t2, player_col
    lw   $t3, 0($t2)

    # (3) Load coin2 bounding box (6×7 coin)
    la   $t4, coin2_row
    lw   $t5, 0($t4)
    la   $t6, coin2_col
    lw   $t7, 0($t6)

    # (4) AABB test for coin2
    addi $t8, $t1, 3
    blt  $t8, $t5, check_coin3_collision
    addi $t8, $t5, 7
    bgt  $t1, $t8, check_coin3_collision
    addi $t8, $t3, 3
    blt  $t8, $t7, check_coin3_collision
    addi $t8, $t7, 6
    bgt  $t3, $t8, check_coin3_collision

    # --- Collision with coin2 detected ---
    la   $t9, coin_counter
    lw   $t8, 0($t9)
    addi $t8, $t8, 1
    sw   $t8, 0($t9)
    li   $t0, 4
    beq  $t8, $t0, win_screen
    la   $t9, coin2_collected
    li   $t8, 1
    sw   $t8, 0($t9)
    # Draw new coin2 at new position (row 5, col 14)
    li   $a0, 5
    li   $a1, 14
    jal  draw_gold_coin_new
    # Update coin2 collision box to match new position.
    li   $t0, 5
    la   $t1, coin2_row
    sw   $t0, 0($t1)
    li   $t0, 15
    la   $t1, coin2_col
    sw   $t0, 0($t1)
    j    continue_game

################################################################
# Coin 3 Collision (6×7 coin)
################################################################
check_coin3_collision:
    # (1) Skip if coin3 already collected
    la   $t9, coin3_collected
    lw   $t8, 0($t9)
    bnez $t8, check_coin4_collision


    # (2) Load player bounding box (assumed 3×3)
    la   $t0, player_row
    lw   $t1, 0($t0)
    la   $t2, player_col
    lw   $t3, 0($t2)

    # (3) Load coin3 bounding box (6×7 coin)
    la   $t4, coin3_row
    lw   $t5, 0($t4)
    la   $t6, coin3_col
    lw   $t7, 0($t6)

    # (4) AABB test for coin3
    addi $t8, $t1, 3
    blt  $t8, $t5, check_coin4_collision
    addi $t8, $t5, 7
    bgt  $t1, $t8, check_coin4_collision
    addi $t8, $t3, 3
    blt  $t8, $t7, check_coin4_collision
    addi $t8, $t7, 6
    bgt  $t3, $t8, check_coin4_collision


    # --- Collision with coin3 detected ---
    la   $t9, coin_counter
    lw   $t8, 0($t9)
    addi $t8, $t8, 1       # Increment coin counter
    sw   $t8, 0($t9)
    li   $t0, 4           # If coin_counter reaches 4, go to game_over
    beq  $t8, $t0, win_screen
    la   $t9, coin3_collected
    li   $t8, 1           # Mark coin3 as collected
    sw   $t8, 0($t9)
    # Draw new coin3 at new position (row 5, col 25)
    li   $a0, 5
    li   $a1, 22
    jal  draw_gold_coin_new
    # Update coin3 collision box to match the new coin position.
    li   $t0, 5
    la   $t1, coin3_row
    sw   $t0, 0($t1)
    li   $t0, 25
    la   $t1, coin3_col
    sw   $t0, 0($t1)
    j    continue_game


################################################################
# Coin 4 Collision (6×7 coin)
################################################################
check_coin4_collision:
    # (1) Skip if coin4 already collected
    la   $t9, coin4_collected
    lw   $t8, 0($t9)
    bnez $t8, no_collision

    # (2) Load player bounding box (assumed 3×3)
    la   $t0, player_row
    lw   $t1, 0($t0)       # player's top row
    la   $t2, player_col
    lw   $t3, 0($t2)       # player's left column

    # (3) Load coin4 bounding box (6×7 coin)
    la   $t4, coin4_row
    lw   $t5, 0($t4)       # coin4's top row
    la   $t6, coin4_col
    lw   $t7, 0($t6)       # coin4's left column

    # (4) AABB test for coin4
    addi $t8, $t1, 3
    blt  $t8, $t5, no_collision   # if player's bottom < coin4's top, no collision
    addi $t8, $t5, 7
    bgt  $t1, $t8, no_collision   # if player's top > coin4's bottom, no collision
    addi $t8, $t3, 3
    blt  $t8, $t7, no_collision   # if player's right < coin4's left, no collision
    addi $t8, $t7, 6
    bgt  $t3, $t8, no_collision   # if player's left > coin4's right, no collision

    # --- Collision with coin4 detected ---
    la   $t9, coin_counter
    lw   $t8, 0($t9)
    addi $t8, $t8, 1           # Increment coin counter
    sw   $t8, 0($t9)
    li   $t0, 4
    beq  $t8, $t0, win_screen   # If coin_counter reaches 4, game over
    la   $t9, coin4_collected
    li   $t8, 1
    sw   $t8, 0($t9)          # Mark coin4 as collected

    # Draw new coin4 at new position (for example, row 5, col 30)
    li   $a0, 5               # new coin4's top row
    li   $a1, 30              # new coin4's left column
    jal  draw_gold_coin_new

    # Update coin4 collision box to match the new coin position.
    li   $t0, 5
    la   $t1, coin4_row
    sw   $t0, 0($t1)
    li   $t0, 30
    la   $t1, coin4_col
    sw   $t0, 0($t1)

    j    continue_game



    ################################################################
    # No Collision Detected with any enemy.
    ################################################################
no_collision:
    # Decrement damage cooldown if active.
    la   $t0, damage_cooldown
    lw   $t1, 0($t0)
    bnez $t1, dec_cooldown_done
    j    frame_delay_start
dec_cooldown_done:
    addi $t1, $t1, -1
    sw   $t1, 0($t0)
frame_delay_start:
    li   $v0, 32
    li   $a0, 40
    syscall
    j    game_loop

enemy_collision_reset:
    la   $t8, enemy_collision_count
    li   $t9, 0
    sw   $t9, 0($t8)
    jal  start_screen
    j    game_loop


################################################################
# Label: continue_game (after processing a collision)
################################################################
continue_game:
    j    game_loop

################################################################
# Label: win screen
################################################################
win_screen:
        # Clear the screen to green.
    li   $s0, BASE_ADDRESS

    li   $t3, 0x0000FF00    # Green color
    li   $t4, 0             # row counter
win_clear_loop:
    li   $t5, 0             # column counter
win_clear_cols:
    mul  $t6, $t4, 512      # row offset in bytes
    mul  $t7, $t5, 4        # column offset in bytes
    add  $t8, $s0, $t6      # add row offset to base address
    add  $t8, $t8, $t7      # add column offset
    sw   $t3, 0($t8)        # set pixel to green
    addi $t5, $t5, 1
    blt  $t5, 128, win_clear_cols
    addi $t4, $t4, 1
    blt  $t4, 64, win_clear_loop

# ---- Draw W2 (row 25, col 35) in white ----
li   $t0, 25        # Base row for W2 (vertical strokes start at row 25)
li   $t1, 35        # Base col for W2 (shifted 10 columns lower from original)
li   $t2, 0

W2_left:
    bge  $t2, 15, W2_left_done
    add  $t3, $t0, $t2         # current row = base row (25) + offset
    mul  $t4, $t3, 512         # compute row offset in bytes
    mul  $t5, $t1, 4           # compute col offset in bytes
    add  $t6, $s0, $t4         # BASE_ADDRESS + row offset
    add  $t6, $t6, $t5         # add col offset
    sw   $t9, 0($t6)          # draw white pixel
    addi $t2, $t2, 1
    j    W2_left
W2_left_done:

li   $t2, 0
W2_right:
    bge  $t2, 15, W2_right_done
    add  $t3, $t0, $t2         # current row = base row (25) + offset
    li   $t7, 42              # Right stroke at col = 35 + 7 = 42
    mul  $t4, $t3, 512
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    W2_right
W2_right_done:

# ---- Diagonals: shift these 10 rows lower (rows 35 to 37) ----

# W2 diagonal left-to-center (rows 35 to 37, starting at col 39)
li   $t2, 0
W2_diag_left:
    bge  $t2, 3, W2_diag_left_done
    addi $t3, $t2, 35         # row = 35 + offset (diagonal starts 10 rows lower than before)
    addi $t4, $t2, 39         # col = 39 + offset
    mul  $t5, $t3, 512
    mul  $t6, $t4, 4
    add  $t7, $s0, $t5
    add  $t7, $t7, $t6
    sw   $t9, 0($t7)
    addi $t2, $t2, 1
    j    W2_diag_left
W2_diag_left_done:

# W2 diagonal right-to-center (rows 35 to 37, starting at col 38)
li   $t2, 0
W2_diag_right:
    bge  $t2, 3, W2_diag_right_done
    addi $t3, $t2, 35         # row = 35 + offset
    li   $t4, 38              # starting at col 38
    sub  $t4, $t4, $t2        # col = 38 - offset
    mul  $t5, $t3, 512
    mul  $t6, $t4, 4
    add  $t7, $s0, $t5
    add  $t7, $t7, $t6
    sw   $t9, 0($t7)
    addi $t2, $t2, 1
    j    W2_diag_right
W2_diag_right_done:


# ---- Draw I beside W2 ----
# Base coordinates for I:
li   $t0, 25       # Base row for I (same vertical alignment as W2)
li   $t1, 55       # Base col for I (placed to the right of W2)

# Draw top horizontal line of I (8 pixels wide) at row 25
li   $t2, 0
I_top:
    bge  $t2, 8, I_top_done
    add  $t3, $t1, $t2    # current col = base col + offset
    mul  $t4, $t0, 512    # row offset (base row)
    mul  $t5, $t3, 4      # col offset
    add  $t6, $s0, $t4    # BASE_ADDRESS + row offset
    add  $t6, $t6, $t5    # add col offset
    sw   $t9, 0($t6)      # draw white pixel
    addi $t2, $t2, 1
    j    I_top
I_top_done:

# Draw vertical stroke of I (a single column) from row 26 to 39
# We'll use the center column of I (base col + 3)
addi $t7, $t1, 3         # center column for I
li   $t2, 1              # start vertical stroke from offset 1
I_vert:
    bge  $t2, 15, I_vert_done  # Draw for 14 rows (row 25+1 to row 25+14)
    add  $t3, $t0, $t2         # current row = base row + offset
    mul  $t4, $t3, 512
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)           # draw white pixel
    addi $t2, $t2, 1
    j    I_vert
I_vert_done:

# Draw bottom horizontal line of I (8 pixels wide) at row = base row + 15
addi $t8, $t0, 15        # Compute bottom row (25 + 15 = 40)
li   $t2, 0
I_bot:
    bge  $t2, 8, I_bot_done
    add  $t3, $t1, $t2     # current col = base col + offset
    mul  $t4, $t8, 512     # row offset for bottom row
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)       # draw white pixel
    addi $t2, $t2, 1
    j    I_bot
I_bot_done:

# ---- Draw N beside I ----
# Base coordinates for N:
li   $t0, 25        # Base row for N (aligned with I)
li   $t1, 75        # Base col for N (placed to the right of I)

# ---- Draw left vertical stroke of N (16 pixels tall) ----
li   $t2, 0
N_left:
    bge  $t2, 16, N_left_done
    add  $t3, $t0, $t2      # current row = base row + offset
    mul  $t4, $t3, 512      # compute row offset (bytes)
    mul  $t5, $t1, 4        # left stroke at base col (65)
    add  $t6, $s0, $t4      # BASE_ADDRESS + row offset
    add  $t6, $t6, $t5      # add column offset
    sw   $t9, 0($t6)        # draw white pixel
    addi $t2, $t2, 1
    j    N_left
N_left_done:

# ---- Draw right vertical stroke of N (16 pixels tall) ----
li   $t2, 0
N_right:
    bge  $t2, 16, N_right_done
    add  $t3, $t0, $t2      # current row = base row + offset
    mul  $t4, $t3, 512      # compute row offset (bytes)
    li   $t7, 82           # right stroke at col = base col + 7 (65 + 7 = 72)
    mul  $t5, $t7, 4        # compute column offset (bytes)
    add  $t6, $s0, $t4      # BASE_ADDRESS + row offset
    add  $t6, $t6, $t5      # add column offset
    sw   $t9, 0($t6)        # draw white pixel
    addi $t2, $t2, 1
    j    N_right
N_right_done:

# ---- Draw diagonal stroke of N (from top-left to bottom-right) ----
li   $t2, 0
# Load constant 15 into $s1 (assuming $s1 is available)
li   $s1, 15
N_diag:
    bge  $t2, 16, N_diag_done
    add  $t3, $t0, $t2      # current row = base row + offset

    # Compute diagonal column = base col + (7 * row_offset) / 15
    li   $t8, 7            # constant 7
    mul  $t8, $t2, $t8     # $t8 = $t2 * 7
    div  $t8, $s1          # divide by 15 (stored in $s1)
    mflo $t8               # $t8 = ($t2 * 7) / 15
    add  $t8, $t1, $t8     # diagonal col = base col for N + computed offset

    # Compute pixel address for diagonal stroke:
    mul  $t4, $t3, 512     # row offset (bytes)
    mul  $t5, $t8, 4       # column offset (bytes)
    add  $t6, $s0, $t4     # BASE_ADDRESS + row offset
    add  $t6, $t6, $t5     # add column offset
    sw   $t9, 0($t6)       # draw white pixel
    addi $t2, $t2, 1
    j    N_diag
N_diag_done:

        # Wait for a key press (screen stays until a key is pressed)
win_wait_key:
    li   $t0, 0xffff0000   # Keyboard MMIO base address
wait_loop:
    lw   $t1, 0($t0)       # Read key status
    beq  $t1, $zero, wait_loop
    j    wait_loop        # Remain in loop so game_loop is never re-entered





################################################################
# Label: game_over (when hearts run out)
################################################################
game_over:
            # Clear the screen to red.
        li   $s0, BASE_ADDRESS

        li   $t3, 0x00FF0000    # Red color
        li   $t4, 0             # row counter
clear_screen_loop:
        li   $t5, 0             # col counter
clear_screen_cols:
        mul  $t6, $t4, 512      # row offset in bytes
        mul  $t7, $t5, 4        # column offset in bytes
        add  $t8, $s0, $t6      # base address + row offset
        add  $t8, $t8, $t7      # add column offset
        sw   $t3, 0($t8)        # set pixel to red
        addi $t5, $t5, 1
        blt  $t5, 128, clear_screen_cols
        addi $t4, $t4, 1
        blt  $t4, 64, clear_screen_loop

        # --- Draw the big letter G (16x16 pixels) ---
        # White color for the letter.
        li   $t9, 0x00FFFFFF

        # Define base coordinates for the big G.
        li   $t0, 20       # base row for G
        li   $t1, 10      # base col for G

        # The design is based on scaling your 8-row pattern by 2.
        # The scaled pattern (each row is relative to the G’s top row):
        #
        # Rows 0-1 (original row 0): full horizontal line (cols 0-15)
        # Rows 2-3 (original row 1): left block only (cols 0-1)
        # Rows 4-5 (original row 2): left block (cols 0-1) and right segment (cols 8-15)
        # Rows 6-7 (original row 3): left block (cols 0-1) and right block (cols 14-15)
        # Rows 8-9 (original row 4): left block (cols 0-1) and right block (cols 14-15)
        # Rows 10-11 (original row 5): left block (cols 0-1) and right segment (cols 8-15)
        # Rows 12-13 (original row 6): left block (cols 0-1) and right block (cols 14-15)
        # Rows 14-15 (original row 7): horizontal line (cols 2-15)

        # ---------------- Row 0: full horizontal line (16 pixels) ----------------
        li   $t2, 0         # column counter
G_big_row0:
        bge  $t2, 16, G_big_row0_done
        # Compute absolute row = base row + 0, absolute col = base col + $t2.
        move $t3, $t0     
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row0
G_big_row0_done:

        # ---------------- Row 1: full horizontal line (16 pixels) ----------------
        addi $t3, $t0, 1    # row = base row + 1
        li   $t2, 0
G_big_row1:
        bge  $t2, 16, G_big_row1_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row1
G_big_row1_done:

        # ---------------- Row 2: left block only (cols 0-1) ----------------
        addi $t3, $t0, 2    # row = base row + 2
        li   $t2, 0
G_big_row2:
        bge  $t2, 2, G_big_row2_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2   # only for t2 = 0,1
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row2
G_big_row2_done:

        # ---------------- Row 3: left block only (cols 0-1) ----------------
        addi $t3, $t0, 3    # row = base row + 3
        li   $t2, 0
G_big_row3:
        bge  $t2, 2, G_big_row3_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row3
G_big_row3_done:

        # ---------------- Row 4: left block (cols 0-1) & right segment (cols 8-15) ----------------
        addi $t3, $t0, 4    # row = base row + 4
        # Left block:
        li   $t2, 0
G_big_row4_left:
        bge  $t2, 2, G_big_row4_left_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row4_left
G_big_row4_left_done:
        # Right segment:
        li   $t2, 8
G_big_row4_right:
        bge  $t2, 16, G_big_row4_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row4_right
G_big_row4_done:

        # ---------------- Row 5: same as Row 4 ----------------
        addi $t3, $t0, 5    # row = base row + 5
        li   $t2, 0
G_big_row5_left:
        bge  $t2, 2, G_big_row5_left_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row5_left
G_big_row5_left_done:
        li   $t2, 8
G_big_row5_right:
        bge  $t2, 16, G_big_row5_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row5_right
G_big_row5_done:

        # ---------------- Row 6: left block (cols 0-1) & right block (cols 14-15) ----------------
        addi $t3, $t0, 6    # row = base row + 6
        li   $t2, 0
G_big_row6_left:
        bge  $t2, 2, G_big_row6_left_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row6_left
G_big_row6_left_done:
        li   $t2, 14
G_big_row6_right:
        bge  $t2, 16, G_big_row6_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row6_right
G_big_row6_done:

        # ---------------- Row 7: same as Row 6 ----------------
        addi $t3, $t0, 7    # row = base row + 7
        li   $t2, 0
G_big_row7_left:
        bge  $t2, 2, G_big_row7_left_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row7_left
G_big_row7_left_done:
        li   $t2, 14
G_big_row7_right:
        bge  $t2, 16, G_big_row7_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row7_right
G_big_row7_done:

        # ---------------- Row 8: same as Rows 6-7 for original row 4 (left block & right block) ----------------
        addi $t3, $t0, 8    # row = base row + 8
        li   $t2, 0
G_big_row8_left:
        bge  $t2, 2, G_big_row8_left_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row8_left
G_big_row8_left_done:
        li   $t2, 14
G_big_row8_right:
        bge  $t2, 16, G_big_row8_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row8_right
G_big_row8_done:

        # ---------------- Row 9: same as Row 8 ----------------
        addi $t3, $t0, 9    # row = base row + 9
        li   $t2, 0
G_big_row9_left:
        bge  $t2, 2, G_big_row9_left_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row9_left
G_big_row9_left_done:
        li   $t2, 14
G_big_row9_right:
        bge  $t2, 16, G_big_row9_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row9_right
G_big_row9_done:

# ---------------- Row 10: same as Row 9 ----------------
addi $t3, $t0, 10   # row = base row + 10
li   $t2, 0
G_big_row10_left:
    bge  $t2, 2, G_big_row10_left_done
    mul  $t4, $t3, 512
    add  $t5, $t1, $t2
    mul  $t5, $t5, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    G_big_row10_left
G_big_row10_left_done:
li   $t2, 14
G_big_row10_right:
    bge  $t2, 16, G_big_row10_done
    mul  $t4, $t3, 512
    add  $t5, $t1, $t2
    mul  $t5, $t5, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    G_big_row10_right
G_big_row10_done:



# ---------------- Row 11: same as Row 9 ----------------
addi $t3, $t0, 11   # row = base row + 11
li   $t2, 0
G_big_row11_left:
    bge  $t2, 2, G_big_row11_left_done
    mul  $t4, $t3, 512
    add  $t5, $t1, $t2
    mul  $t5, $t5, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    G_big_row11_left
G_big_row11_left_done:
li   $t2, 14
G_big_row11_right:
    bge  $t2, 16, G_big_row11_done
    mul  $t4, $t3, 512
    add  $t5, $t1, $t2
    mul  $t5, $t5, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    G_big_row11_right
G_big_row11_done:





        # ---------------- Row 12: left block (cols 0-1) & right block (cols 14-15) ----------------
        addi $t3, $t0, 12   # row = base row + 12
        li   $t2, 0
G_big_row12_left:
        bge  $t2, 2, G_big_row12_left_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row12_left
G_big_row12_left_done:
        li   $t2, 14
G_big_row12_right:
        bge  $t2, 16, G_big_row12_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row12_right
G_big_row12_done:

        # ---------------- Row 13: same as Row 12 ----------------
        addi $t3, $t0, 13   # row = base row + 13
        li   $t2, 0
G_big_row13_left:
        bge  $t2, 2, G_big_row13_left_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row13_left
G_big_row13_left_done:
        li   $t2, 14
G_big_row13_right:
        bge  $t2, 16, G_big_row13_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row13_right
G_big_row13_done:

        # ---------------- Row 14: horizontal segment (cols 2-15) ----------------
        addi $t3, $t0, 14   # row = base row + 14
	li   $t2, 2
G_big_row14:
        bge  $t2, 16, G_big_row14_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row14
G_big_row14_done:

        # ---------------- Row 15: same as Row 14 ----------------
        addi $t3, $t0, 15   # row = base row + 15
        li   $t2, 2
G_big_row15:
        bge  $t2, 16, G_big_row15_done
        mul  $t4, $t3, 512
        add  $t5, $t1, $t2
        mul  $t5, $t5, 4
        add  $t6, $s0, $t4
        add  $t6, $t6, $t5
        sw   $t9, 0($t6)
        addi $t2, $t2, 1
        j    G_big_row15
G_big_row15_done:

# ========= Draw Big "A" Beside the Big "G" on the Game Over Screen =========
# (Assumes $s0 holds BASE_ADDRESS and $t9 is still set to white: 0x00FFFFFF)

# Set base coordinates for the A (positioned beside the G)
li   $t0, 20      # Base row for A (same vertical alignment as G)
li   $t1, 31      # Base column for A (to the right of G, which ends near col 25)
li   $t2, 0

# Draw top horizontal line of A (8 pixels wide)
A_top_loop_go:
    bge  $t2, 7, A_top_done_go
    add  $t3, $t1, $t2      # current col = base col + offset
    mul  $t4, $t0, 512      # row offset (base row * 512)
    mul  $t5, $t3, 4        # col offset (current col * 4)
    add  $t6, $s0, $t4      # address = BASE_ADDRESS + row offset
    add  $t6, $t6, $t5      # add col offset
    sw   $t9, 0($t6)        # write white pixel
    addi $t2, $t2, 1
    j    A_top_loop_go
A_top_done_go:

# Draw the left vertical leg of A
li   $t0, 21      # start one row below the top
A_left_vert_go:
    bgt  $t0, 35, A_left_done_go   # Draw until row 35 (adjust for desired height)
    mul  $t4, $t0, 512
    li   $t7, 30     # left side stays at base col 27
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    A_left_vert_go
A_left_done_go:

# Draw the right vertical leg of A
li   $t0, 21      # reset row counter for the right leg
A_right_vert_go:
    bgt  $t0, 35, A_right_done_go
    mul  $t4, $t0, 512
    li   $t7, 38     # right side at col 35 (adjust for width)
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    A_right_vert_go
A_right_done_go:

# Draw the horizontal crossbar of A
li   $t0, 28      # choose a row for the crossbar (adjust as needed)
li   $t2, 30      # start at the left side of A
A_crossbar_go:
    bge  $t2, 39, A_crossbar_done_go  # Draw from col 27 up to (but not including) col 36
    mul  $t4, $t0, 512
    mul  $t5, $t2, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    A_crossbar_go
A_crossbar_done_go:

# ---- Draw M (row 20, col 44) ----
# This is the original W drawing code with label names changed to M.
li   $t0, 20         # Base row for M (changed from 15 to 20)
li   $t1, 44         # Base column for M (changed from 50 to 44)
li   $t2, 0
M_left:
    bge $t2, 16, M_left_done
    add $t3, $t0, $t2
    mul $t4, $t3, 512
    mul $t5, $t1, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j    M_left
M_left_done:

li   $t2, 0
M_right:
    bge $t2, 16, M_right_done
    add $t3, $t0, $t2
    li $t7, 51         # Right stroke now at col 51 (44 + 7)
    mul $t4, $t3, 512
    mul $t5, $t7, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j    M_right
M_right_done:

# M diagonal left-to-center (row 30 to 32, cols 48 to 50)
li   $t2, 0
M_diag_left:
    bge $t2, 3, M_diag_left_done
    addi $t3, $t2, 20    # row = 20 + 10 = 30, plus t2 offset
    addi $t4, $t2, 45    # col = 44 + 4 = 48, plus t2 offset
    mul  $t5, $t3, 512
    mul  $t6, $t4, 4
    add  $t7, $s0, $t5
    add  $t7, $t7, $t6
    sw   $t9, 0($t7)
    addi $t2, $t2, 1
    j    M_diag_left
M_diag_left_done:

# M diagonal right-to-center (row 30 to 32, cols 47 downwards)
li   $t2, 0
M_diag_right:
    bge $t2, 3, M_diag_right_done
    addi $t3, $t2, 20    # row = 20 + 10 = 30, plus t2 offset
    li   $t4, 50         # col = 44 + 3 = 47
    sub  $t4, $t4, $t2   # adjust by t2 (t2 = 0,1,2)
    mul  $t5, $t3, 512
    mul  $t6, $t4, 4
    add  $t7, $s0, $t5
    add  $t7, $t7, $t6
    sw   $t9, 0($t7)
    addi $t2, $t2, 1
    j    M_diag_right
M_diag_right_done:

# ---- Draw E (row 20, col 56) ----
# Base coordinates for E
li   $t0, 20        # Base row for E
li   $t1, 56        # Base column for E (moved 2 cols left from 58 to 56)
li   $t2, 0

# Draw left vertical stroke of E (16 pixels tall)
E_left_vert:
    bge $t2, 16, E_left_vert_done  # Draw 16 rows (from row 20 to row 35)
    add  $t3, $t0, $t2             # current row = base row + offset
    mul  $t4, $t3, 512             # compute row offset in bytes
    mul  $t5, $t1, 4               # compute col offset (left stroke at base col)
    add  $t6, $s0, $t4             # BASE_ADDRESS + row offset
    add  $t6, $t6, $t5             # add column offset
    sw   $t9, 0($t6)              # store white pixel (in $t9)
    addi $t2, $t2, 1
    j    E_left_vert
E_left_vert_done:

# Draw top horizontal stroke of E (8 pixels wide) at row = base row (20)
li   $t2, 0
E_top:
    bge $t2, 8, E_top_done
    add  $t3, $t1, $t2            # current col = base col + offset
    mul  $t4, $t0, 512            # row offset for row 20
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    E_top
E_top_done:

# Draw middle horizontal stroke of E (8 pixels wide) at row = base row + 8 (i.e. row 28)
li   $t2, 0
li   $t7, 20
addi $t8, $t7, 8             # middle row = 28
E_middle:
    bge $t2, 6, E_middle_done
    add  $t3, $t1, $t2         # current col = base col + offset
    mul  $t4, $t8, 512         # row offset for row 28
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    E_middle
E_middle_done:

# Draw bottom horizontal stroke of E (8 pixels wide) at row = base row + 15 (i.e. row 35)
li   $t2, 0
li   $t7, 20
addi $t8, $t7, 15           # bottom row = 35
E_bottom:
    bge $t2, 8, E_bottom_done
    add  $t3, $t1, $t2         # current col = base col + offset
    mul  $t4, $t8, 512         # row offset for row 35
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    E_bottom
E_bottom_done:

# ---- Draw thicker and taller O (14x10 with 2-pixel thick border) under the M ----
# Base coordinates for O:
li   $t0, 41        # Base row for O (moved 5 pixels lower)
li   $t1, 43        # Base col for O (same as before)
# Assumes $s0 holds BASE_ADDRESS and $t9 holds white (0x00FFFFFF)

# -------------------------------------
# Draw top border (2 rows: rows 41 and 42)
li   $t2, 0
O_top_border:
    bge  $t2, 2, O_top_border_done
    add  $t3, $t0, $t2
    li   $t4, 0
O_top_border_col:
    bge  $t4, 10, O_top_border_next
    add  $t5, $t1, $t4
    mul  $t6, $t3, 512
    mul  $t7, $t5, 4
    add  $t8, $s0, $t6
    add  $t8, $t8, $t7
    sw   $t9, 0($t8)
    addi $t4, $t4, 1
    j    O_top_border_col
O_top_border_next:
    addi $t2, $t2, 1
    j    O_top_border
O_top_border_done:

# -------------------------------------
# Draw bottom border (rows 53 and 54: base row + 12 and +13)
li   $t2, 0
O_bottom_border:
    bge  $t2, 2, O_bottom_border_done
    addi $t3, $t0, 12
    add  $t3, $t3, $t2
    li   $t4, 0
O_bottom_border_col:
    bge  $t4, 10, O_bottom_border_next
    add  $t5, $t1, $t4
    mul  $t6, $t3, 512
    mul  $t7, $t5, 4
    add  $t8, $s0, $t6
    add  $t8, $t8, $t7
    sw   $t9, 0($t8)
    addi $t4, $t4, 1
    j    O_bottom_border_col
O_bottom_border_next:
    addi $t2, $t2, 1
    j    O_bottom_border
O_bottom_border_done:

# -------------------------------------
# Draw left border (2 columns) for middle rows (rows 43 to 52)
li   $t2, 0
O_left_border:
    bge  $t2, 10, O_left_border_done
    addi $t3, $t0, 2
    add  $t3, $t3, $t2
    li   $t4, 0
O_left_border_col:
    bge  $t4, 2, O_left_border_next
    add  $t5, $t1, $t4
    mul  $t6, $t3, 512
    mul  $t7, $t5, 4
    add  $t8, $s0, $t6
    add  $t8, $t8, $t7
    sw   $t9, 0($t8)
    addi $t4, $t4, 1
    j    O_left_border_col
O_left_border_next:
    addi $t2, $t2, 1
    j    O_left_border
O_left_border_done:

# -------------------------------------
# Draw right border (2 columns) for middle rows (rows 43 to 52)
li   $t2, 0
O_right_border:
    bge  $t2, 10, O_right_border_done
    addi $t3, $t0, 2
    add  $t3, $t3, $t2
    li   $t4, 0
O_right_border_col:
    bge  $t4, 2, O_right_border_next
    li   $t5, 8
    add  $t5, $t1, $t5
    add  $t5, $t5, $t4
    mul  $t6, $t3, 512
    mul  $t7, $t5, 4
    add  $t8, $s0, $t6
    add  $t8, $t8, $t7
    sw   $t9, 0($t8)
    addi $t4, $t4, 1
    j    O_right_border_col
O_right_border_next:
    addi $t2, $t2, 1
    j    O_right_border
O_right_border_done:

# ---- Draw V beside the O ----
# Assumes:
#   $s0 holds BASE_ADDRESS
#   $t9 holds white (0x00FFFFFF)
# This V is drawn starting at row 41 with its center at col 55, height = 14 pixels.
# The arms converge to a point at the bottom.
 
    li   $t0, 0          # Row counter (i: 0 to 13 for 14 rows)
    li   $t1, 41         # Base row for V (top row)
    li   $t2, 59         # Center column for V
    li   $t3, 3          # Maximum horizontal offset at the top = 3 pixels
    li   $t7, 13         # Denom for interpolation (height - 1 = 13)
 
V_loop:
    bge  $t0, 14, V_done         # If row counter >= 14, we're done.
    add  $t4, $t1, $t0           # Current row = base row + i
 
    # Compute offset = 3 - (3 * i) / 13
    mul  $t5, $t0, $t3           # t5 = i * 3
    div  $t5, $t7                # Divide by 13; quotient goes to LO
    mflo $t5                    # t5 = (i*3)/13 (integer division)
    sub  $t6, $t3, $t5          # t6 = offset = 3 - (i*3)/13
 
    # Compute left and right pixel columns:
    sub  $t8, $t2, $t6          # left pixel col = center - offset
    add  $s1, $t2, $t6          # s1 = right pixel col = center + offset
 
    # Draw left pixel:
    mul  $s2, $t4, 512          # s2 = current row * 512 (row offset in bytes)
    mul  $s3, $t8, 4            # s3 = left col * 4 (column offset in bytes)
    add  $s4, $s0, $s2          # s4 = BASE_ADDRESS + row offset
    add  $s4, $s4, $s3          # s4 = final pixel address for left pixel
    sw   $t9, 0($s4)            # store white pixel at left location
 
    # Draw right pixel:
    mul  $s3, $s1, 4            # s3 = right col * 4 (reuse s3)
    add  $s4, $s0, $s2          # s4 = BASE_ADDRESS + row offset (reuse s4)
    add  $s4, $s4, $s3          # s4 = final pixel address for right pixel
    sw   $t9, 0($s4)            # store white pixel at right location
 
    addi $t0, $t0, 1            # Increment row counter
    j    V_loop
V_done:


# ---- Draw E beside the V ----
# Base coordinates for E_3
li $t0, 41        # base row
li $t1, 66        # base column (adjust as needed)

# Top horizontal line of E_3 (row 41)
li   $t2, 0
E3_top:
    bge $t2, 7, E3_top_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    E3_top
E3_top_done:

# Left vertical line of E_3 (col = base col)
li   $t2, 0
E3_left:
    bge $t2, 14, E3_left_done
    add  $t3, $t0, $t2
    mul  $t4, $t3, 512
    mul  $t5, $t1, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    E3_left
E3_left_done:

# Middle horizontal line of E_3 (row 48)
li   $t2, 0
li   $t7, 48
E3_mid:
    bge $t2, 6, E3_mid_done
    add  $t3, $t1, $t2
    mul  $t4, $t7, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    E3_mid
E3_mid_done:

# Bottom horizontal line of E_3 (row 54)
li   $t2, 0
li   $t7, 54
E3_bot:
    bge $t2, 7, E3_bot_done
    add  $t3, $t1, $t2
    mul  $t4, $t7, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    E3_bot
E3_bot_done:

# ---- Draw R_2 (moved one pixel down; top starts at row 41, col 75) ----

# Top Horizontal Stroke (row 41)
li   $t0, 41        # base row for top stroke
li   $t1, 75        # base column
li   $t2, 0         # column offset counter
R_top_loop2:
    bge  $t2, 6, R_top_done2
    add  $t3, $t1, $t2         # current col = base col + offset
    mul  $t4, $t0, 512         # row offset in bytes
    mul  $t5, $t3, 4           # column offset in bytes
    add  $t6, $s0, $t4         # BASE_ADDRESS + row offset
    add  $t6, $t6, $t5         # final pixel address
    sw   $t9, 0($t6)           # draw pixel
    addi $t2, $t2, 1
    j    R_top_loop2
R_top_done2:

# Left Vertical Stroke (rows 41 to 52)
li   $t0, 41        # starting row for left vertical stroke
R_left_vert2:
    bgt  $t0, 54, R_left_done2
    mul  $t4, $t0, 512         # row offset
    mul  $t5, $t1, 4           # left column offset (base col remains 75)
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    R_left_vert2
R_left_done2:

# Top Right Vertical Stroke (rows 42 to 45)
li   $t0, 42        # starting row for top right vertical stroke
li   $t7, 81        # right stroke column = base col + 6 (75+6=81)
R_top_right_vert2:
    bgt  $t0, 45, R_top_right_done2
    mul  $t4, $t0, 512
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    R_top_right_vert2
R_top_right_done2:

# Horizontal Cross Stroke (row 46)
li   $t0, 46        # row for cross stroke
li   $t2, 0         # column offset counter
R_cross_loop2:
    bge  $t2, 6, R_cross_done2
    add  $t3, $t1, $t2         # current col = base col + offset
    mul  $t4, $t0, 512         # row offset in bytes
    mul  $t5, $t3, 4           # column offset in bytes
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    R_cross_loop2
R_cross_done2:

# Bottom Vertical Leg (rows 47 to 52)
li   $t0, 47        # starting row for bottom leg
li   $t7, 81        # right column remains 81
R_bottom_leg2:
    bgt  $t0, 54, R_bottom_done2
    mul  $t4, $t0, 512
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    R_bottom_leg2
R_bottom_done2:


        # --- Wait for a key press (stays on screen) ---
wait_key:
        li   $t0, 0xffff0000   # Keyboard MMIO base address
        lw   $t1, 0($t0)       # Read key status
        beq  $t1, $zero, wait_key
        jr   $ra              # Return or halt execution




######################################################################
# INPUT HANDLERS
######################################################################
move_left:
    lw   $t4, player_col
    li   $t5, 2
    ble  $t4, $t5, done_moving   # Prevent moving left if at or below boundary
    addi $t4, $t4, -4            # Subtract 2 units => 2*4 = 8 pixels
    sw   $t4, player_col
    # Set facing to left (1)
    li   $t6, 1
    sw   $t6, player_facing
done_moving:
    lw   $t7, move_delay_value
    sw   $t7, move_delay_counter
    j skip_input

move_right:
    lw   $t4, player_col
    li   $t5, 124
    bge  $t4, $t5, done_moving2  # Prevent moving right if at or beyond boundary
    addi $t4, $t4, 4             # Add 2 units => 2*4 = 8 pixels
    sw   $t4, player_col
    # Set facing to right (0)
    li   $t6, 0
    sw   $t6, player_facing
done_moving2:
    lw   $t7, move_delay_value
    sw   $t7, move_delay_counter
    j skip_input

try_jump:
    # Check if the player is on the ground.
    la   $t0, is_jumping
    lw   $t1, 0($t0)
    beqz $t1, perform_normal_jump   # If not in air, perform a normal jump

    # Otherwise, player is mid-air. Check if double jump is available.
    la   $t2, double_jump_available
    lw   $t3, 0($t2)
    beqz $t3, game_loop            # If already 0, extra jump not allowed; ignore jump

    # Allow the extra (mid-air) jump.
    la   $t4, player_velocity
    li   $t5, -6                  # Set desired jump velocity (adjust as needed)
    sw   $t5, 0($t4)
    li   $t6, 0                   # Mark extra jump as used.
    sw   $t6, 0($t2)
    lw   $t7, move_delay_value
    sw   $t7, move_delay_counter
    j    skip_input

perform_normal_jump:
    # Normal ground jump.
    li   $t1, 1
    sw   $t1, 0($t0)              # Set is_jumping flag
    la   $t4, player_velocity
    li   $t5, -6                  # Set jump strength (adjust as needed)
    sw   $t5, 0($t4)
    lw   $t7, move_delay_value
    sw   $t7, move_delay_counter
    j    skip_input





######################################################################
# GRAVITY ENGINE (platform is fully solid: no climbing from below)
######################################################################
apply_gravity:
    la   $t0, is_jumping
    lw   $t1, 0($t0)
    la   $t2, player_row
    lw   $t3, 0($t2)       # old player row in $t3
    la   $t4, player_velocity
    lw   $t5, 0($t4)       # current velocity in $t5
    bnez $t1, apply_physics
    li   $t6, 60          # floor: max row = 60
    beq  $t3, $t6, done_gravity
    li   $t1, 1
    sw   $t1, 0($t0)
    li   $t5, 1
    sw   $t5, 0($t4)
    j    apply_physics

apply_physics:
    move $t6, $t3         # save old row in $t6
    add  $t3, $t3, $t5    # new row = old row + velocity

    # For collision checks, compute bottoms:
    addi $t7, $t3, 3      # new_bottom = new row + 3
    addi $t9, $t6, 3      # old_bottom = old row + 3

    # Branch based on velocity:
    bgtz $t5, check_downward         # if falling (velocity > 0)
    bltz $t5, check_upward_A         # if jumping (velocity < 0)
    j no_platform_collision          # if velocity == 0

#---------------- Downward Collision for Platform A (row 50, cols 10–30) ----------------
check_downward:
    slti $s4, $t9, 50          # $s4 = 1 if old_bottom < 50
    slti $s5, $t7, 50          # $s5 = 1 if new_bottom < 50
    beq  $s4, $zero, check_platform_B  # if old_bottom not less than 50, go to next
    bnez $s5, check_platform_B          # if new_bottom still less than 50, no collision with A
    j    check_horizontal_A

check_horizontal_A:
    lw   $s6, player_col      # player's left col
    addi $t8, $s6, 3          # player's right col = left + 3
    li   $s7, 31              # if player's left col >= 31, no collision
    bge  $s6, $s7, check_platform_B
    li   $s7, 10              # platform A left boundary = 10
    blt  $t8, $s7, check_platform_B  # if player's right col < 10, no collision
        # Collision detected for Platform A – clamp player's row to 46.
        # Landing on Platform A – clamp player row.
    li   $t3, 46
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    # Notice: We do NOT reset double_jump_available here.
    j    done_gravity


#---------------- Downward Collision for Platforms B–E ----------------
# (As in your previous code; unchanged from earlier snippet.)
check_platform_B:
    slti $s4, $t9, 40
    slti $s5, $t7, 40
    beq  $s4, $zero, check_platform_C
    bnez $s5, check_platform_C
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 71
    bge  $s6, $s7, check_platform_C
    li   $s7, 40
    blt  $t8, $s7, check_platform_C
    li   $t3, 36
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_platform_C:
    slti $s4, $t9, 30
    slti $s5, $t7, 30
    beq  $s4, $zero, check_platform_D
    bnez $s5, check_platform_D
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 106
    bge  $s6, $s7, check_platform_D
    li   $s7, 80
    blt  $t8, $s7, check_platform_D
    li   $t3, 26
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_platform_D:
    # Check if the player is falling past platform D’s top (row 25)
    slti $s4, $t9, 25         # old_bottom < 25?
    slti $s5, $t7, 25         # new_bottom < 25?
    beq  $s4, $zero, check_platform_E
    bnez $s5, check_platform_E

    # Load the player's horizontal coordinates
    lw   $s6, player_col     # player's left column in $s6
    addi $t8, $s6, 3         # player's right column (player width = 4 pixels)

    # Get Platform D's current horizontal boundaries:
    la   $t0, platform_d_left  # address of platform D's left value
    lw   $t1, 0($t0)           # current left bound of Platform D
    addi $t2, $t1, 26          # compute right bound = left + 26

    # If player's horizontal span is outside the platform, skip collision:
    bge  $s6, $t2, check_platform_E  # if player's left >= platform's right, no collision
    blt  $t8, $t1, check_platform_E   # if player's right < platform's left, no collision

    # Collision detected: clamp player's row to platform D top minus player height
    li   $t3, 21              # set player_row = 21 (since platform top is at 25)
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity


check_platform_E:
    slti $s4, $t9, 45
    slti $s5, $t7, 45
    beq  $s4, $zero, no_platform_collision
    bnez $s5, no_platform_collision
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 121
    bge  $s6, $s7, no_platform_collision
    li   $s7, 95
    blt  $t8, $s7, no_platform_collision
    li   $t3, 41
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

#---------------- Upward Collision Checks for Platforms A–E ----------------
check_upward_A:
    # For upward collision on Platform A (row 50)
    ble  $t6, 50, check_upward_B  # if old top <= 50, no collision here
    bgt  $t3, 50, check_upward_B  # if new top > 50, no collision
    j    check_horizontal_up_A
check_horizontal_up_A:
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 31
    bge  $s6, $s7, check_upward_B
    li   $s7, 10
    blt  $t8, $s7, check_upward_B
    # Upward collision detected for Platform A: clamp player's row to 51
    li   $t3, 51
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_upward_B:
    # For upward collision on Platform B (row 40)
    ble  $t6, 40, check_upward_C
    bgt  $t3, 40, check_upward_C
    j    check_horizontal_up_B
check_horizontal_up_B:
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 71
    bge  $s6, $s7, check_upward_C
    li   $s7, 40
    blt  $t8, $s7, check_upward_C
    # Upward collision detected for Platform B: clamp player's row to 41
    li   $t3, 41
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_upward_C:
    # For upward collision on Platform C (row 30)
    ble  $t6, 30, check_upward_D
    bgt  $t3, 30, check_upward_D
    j    check_horizontal_up_C
check_horizontal_up_C:
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 106
    bge  $s6, $s7, check_upward_D
    li   $s7, 80
    blt  $t8, $s7, check_upward_D
    # Upward collision detected for Platform C: clamp player's row to 31
    li   $t3, 31
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_upward_D:
    # If the old top is above platform D’s top and the new top is below or at platform D’s top, we have a potential collision.
    ble  $t6, 25, check_upward_E
    bgt  $t3, 25, check_upward_E
    j    check_horizontal_up_D

check_horizontal_up_D:
    lw   $s6, player_col         # player's left column
    addi $t8, $s6, 3             # player's right column
    la   $t0, platform_d_left    # load platform D's current left
    lw   $t1, 0($t0)             # current left boundary
    addi $t2, $t1, 26            # current right boundary (platform width = 26)
    bge  $s6, $t2, check_upward_E  # if player's left >= platform's right, no collision
    blt  $t8, $t1, check_upward_E  # if player's right < platform's left, no collision

    # Collision detected from below: clamp player's row appropriately.
    li   $t3, 26                # set player_row = 26
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity


check_upward_E:
    # For upward collision on Platform E (row 45)
    ble  $t6, 45, no_platform_collision  # if old top <= 45, no upward collision
    bgt  $t3, 45, no_platform_collision  # if new top > 45, no collision
    j    check_horizontal_up_E
check_horizontal_up_E:
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 121
    bge  $s6, $s7, no_platform_collision
    li   $s7, 95
    blt  $t8, $s7, no_platform_collision
    # Upward collision detected for Platform E: clamp player's row to 46
    li   $t3, 46
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

# If no upward collision detected for any platform:
no_platform_collision:
    bgt  $t3, 60, set_floor
    sw   $t3, player_row
    addi $t5, $t5, 1
    sw   $t5, player_velocity

done_gravity:
    jr   $ra

set_floor:
    li   $t3, 60
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    jr   $ra

end:
    j end

######################################################################
# Subroutine: draw_gold_coin_new
# Draws a 6x7 coin sprite using a 2-bit-per-pixel pattern.
#
# Input:
#   $a0 = top row (pixel row) where the coin will be drawn.
#   $a1 = left column (pixel column) where the coin will be drawn.
# Assumes:
#   $s0 contains the framebuffer base address.
#
# The coin pattern is defined in coin_pattern_6x7. Each pixel is stored
# as 2 bits (packed into a 12-bit field per row):
#   0 = transparent (skip)
#   1 = gold (bright gold: 0x00FFD700)
#   2 = orange (orange: 0x00FFA500)
#
# Each row is stored as a .hword (2 bytes). For a given coin column j,
# the 2-bit pixel is at bit position = ( (6 - 1 - j) * 2 ).
######################################################################
draw_gold_coin_new:
    li   $t0, 0              # coin row index (0 .. 6)
row_loop:
    bge  $t0, 7, coin_done_new   # finished if row index >= 7

    # Load coin pattern for the current row.
    la   $t8, coin_pattern_6x7    # base address of coin pattern array
    mul  $t9, $t0, 2              # offset: row index * 2 bytes (.hword)
    add  $t8, $t8, $t9            # address for current row pattern
    lh   $t2, 0($t8)             # load coin row pattern (12 bits used)

    li   $t1, 0              # coin column index (0 .. 5)
col_loop:
    bge  $t1, 6, next_row_new  # if col index >= 6, next row

    # Compute shift = (5 - coin column) * 2.
    li   $t3, 5
    sub  $t3, $t3, $t1       # t3 = 5 - coin col
    sll  $t3, $t3, 1         # t3 = (5 - coin col) * 2

    srlv $t4, $t2, $t3       # shift pattern right by t3 bits
    andi $t4, $t4, 3         # t4 = 2-bit pixel value

    beq  $t4, $zero, skip_pixel_new   # if pixel value is 0, skip drawing

    # Determine color based on pixel value.
    li   $t7, 0             # t7 will hold the color value
    li   $t5, 1
    beq  $t4, $t5, draw_gold_pixel_new  # if pixel == 1, use gold color
    li   $t5, 2
    beq  $t4, $t5, draw_orange_pixel_new  # if pixel == 2, use orange color
    # Fallback for an unexpected value:
    li   $t7, 0x00FFFFFF     # white color as default
    j    set_pixel_new

draw_gold_pixel_new:
    li   $t7, 0x00FFD700     # bright gold color
    j    set_pixel_new

draw_orange_pixel_new:
    li   $t7, 0x00FFA500     # orange color
    j    set_pixel_new

set_pixel_new:
    # Compute screen pixel address.
    # Current row = $a0 + coin row; multiply by 512 (row stride).
    addu $t8, $a0, $t0
    sll  $t8, $t8, 9         # multiply by 512 (2^9)
    # Current col = $a1 + coin col; multiply by 4 (pixel size).
    addu $t9, $a1, $t1
    sll  $t9, $t9, 2         # multiply by 4 (2^2)
    addu $t8, $t8, $t9       # add row and col offset
    addu $t8, $s0, $t8       # add framebuffer base address
    sw   $t7, 0($t8)         # store the pixel color

skip_pixel_new:
    addi $t1, $t1, 1         # next coin column
    j    col_loop

next_row_new:
    addi $t0, $t0, 1         # next coin row
    j    row_loop

coin_done_new:
    jr   $ra                # return from subroutine


######################################################################
# erase_coin
# Overwrites a 9×8 area with color 0xFF080484,
# starting 5 rows below coin_row.
#
# Assumes:
#   coin_row, coin_col hold the coin's top-left (original coin position)
#   $s0 = base address of the framebuffer
######################################################################
erase_coin:
    #---------------------------------------------------------------
    # 1) Compute the starting row and column for the erase region.
    #    The region begins at (coin_row+5, coin_col)
    #---------------------------------------------------------------
    la   $t0, coin_row      # Load address of coin_row
    lw   $t1, 0($t0)        # t1 = coin_row
    addi $t1, $t1, 5        # t1 = coin_row + 5

    la   $t0, coin_col      # Load address of coin_col
    lw   $t2, 0($t0)        # t2 = coin_col

    #---------------------------------------------------------------
    # 2) Precompute the base address for the erase region.
    #    base_address = $s0 + ((coin_row+5) * 512) + (coin_col * 4)
    #---------------------------------------------------------------
    sll  $t3, $t1, 9        # t3 = (coin_row+5) * 512
    sll  $t4, $t2, 2        # t4 = coin_col * 4
    addu $t5, $s0, $t3      # t5 = $s0 + (coin_row+5)*512
    addu $t5, $t5, $t4      # t5 = base address for the erase region

    #---------------------------------------------------------------
    # 3) Set the erase color to 0xFF080484.
    #---------------------------------------------------------------
    li   $t6, 0xFF080484

    #---------------------------------------------------------------
    # 4) Loop over the 8 rows and 9 columns of the region.
    #---------------------------------------------------------------
    li   $t7, 0            # Row index (0..7)
erase_row_loop:
    bge  $t7, 8, erase_done   # If row index >= 8, we're done with rows.
    
    li   $t8, 0            # Column index (0..8)
erase_col_loop:
    bge  $t8, 9, next_row     # If column index >= 9, move to the next row.
    
    # Compute pixel offset:
    #   offset = (row_index * 512) + (col_index * 4)
    sll  $t9, $t7, 9       # t9 = row_index * 512
    sll  $t0, $t8, 2       # t0 = col_index * 4
    addu $t9, $t9, $t0     # t9 = offset for this pixel within the region
    addu $t9, $t5, $t9     # t9 = final framebuffer address for this pixel
    
    sw   $t6, 0($t9)       # Write the erase color at that address
    
    addi $t8, $t8, 1       # Increment column index
    j    erase_col_loop

next_row:
    addi $t7, $t7, 1       # Increment row index
    j    erase_row_loop

erase_done:
    jr   $ra




##########################
erase_heart:
    # Input: $a0 = heart index to erase (0 = leftmost; 3 = far right when starting with 4 hearts)
    # Base coordinates for hearts (as drawn in your code):
    #   Top row: 4
    #   Left col of first heart: 98
    #   Each heart occupies a 4x5 block and is spaced 7 columns apart.
    
    li   $t0, 98         # Base column for the first heart
    li   $t1, 7          # Spacing increment per heart
    mul  $t2, $a0, $t1   # t2 = heart index * 7
    add  $t2, $t0, $t2   # t2 now holds the starting column for the heart to erase

    li   $t3, 4          # Base row for hearts (row 4)
    li   $t7, 0          # Row offset counter (0 .. 3)
erase_heart_row_loop:
    bge  $t7, 4, erase_heart_done  # If row offset >= 4, we're done
    add  $t8, $t3, $t7   # t8 = current row = base row + row offset

    li   $t5, 0          # Column offset counter (0 .. 4)
erase_heart_col_loop:
    bge  $t5, 5, next_heart_row   # If column offset >= 5, move to next row
    add  $t9, $t2, $t5   # t9 = current column = starting col + column offset

    # Compute pixel address:
    #   pixel address = BASE_ADDRESS + (current row * 512) + (current col * 4)
    sll  $a1, $t8, 9     # $a1 = current row * 512  (512 = 2^9)
    sll  $a2, $t9, 2     # $a2 = current col * 4    (4 = 2^2)
    add  $a1, $s0, $a1   # $a1 = BASE_ADDRESS + (row offset)
    add  $a1, $a1, $a2   # $a1 = final pixel address
    lw   $a3, black     # $a3 = black color (0x00000000)
    sw   $a3, 0($a1)    # Overwrite pixel with black

    addi $t5, $t5, 1    # Next column offset
    j    erase_heart_col_loop
next_heart_row:
    addi $t7, $t7, 1    # Next row in the heart block
    j    erase_heart_row_loop
erase_heart_done:
    jr   $ra


restart_game:
    # Reset player state.
    li   $t0, 60
    sw   $t0, player_row
    li   $t0, 2
    sw   $t0, player_col
    li   $t0, 0
    sw   $t0, player_velocity
    sw   $t0, is_jumping
    li   $t0, 0        # Assuming 0 means default facing (right)
    sw   $t0, player_facing

    # Reset health.
    li   $t0, 4
    sw   $t0, hearts
    li   $t0, 0
    sw   $t0, enemy_collision_count
    sw   $t0, damage_cooldown

    # Reset coin data.
    li   $t0, 0
    sw   $t0, coin_counter
    sw   $t0, coin_collected
    sw   $t0, coin2_collected
    sw   $t0, coin3_collected
    sw   $t0, coin4_collected

    # (Optional) Reset enemy positions.
    li   $t0, 20
    sw   $t0, enemy_row
    li   $t0, 0
    sw   $t0, enemy_col
    li   $t0, 45
    sw   $t0, enemy2_row
    li   $t0, 0
    sw   $t0, enemy2_col
    li   $t0, 35
    sw   $t0, enemy3_row
    li   $t0, 0
    sw   $t0, enemy3_col

    # (Optional) Clear other game state or buffers as needed.
    # You might also want to reset any score or timer variables here.

    # Jump to the start of the main game loop.
    j main_game_loop


########################################################################
# START SCREEN SUBROUTINE
########################################################################
start_screen:
    # Clear the display (64 rows x 128 cols) with dark blue ($s3)
    li   $s0, BASE_ADDRESS    # Ensure $s0 is set to the base address
    li   $s3, 0x00000080      # Dark blue background
    li   $t4, 0               # row counter (0 .. 63)
start_bg_row_loop:
    li   $t5, 0               # col counter (0 .. 127)
start_bg_col_loop:
    mul  $t6, $t4, 512        # compute row offset in bytes
    mul  $t7, $t5, 4          # compute col offset in bytes
    add  $t8, $s0, $t6        # base address + row offset
    add  $t8, $t8, $t7        # + col offset
    sw   $s3, 0($t8)          # set pixel to dark blue
    addi $t5, $t5, 1
    blt  $t5, 128, start_bg_col_loop
    addi $t4, $t4, 1
    blt  $t4, 64, start_bg_row_loop

# "START" title: shifted 15 columns right and 20 rows down (35 down - 15 up = net 20 rows)

# ========== Big "S" ==========
li   $t9, 0x00FFFFFF
li   $t0, 40              # row
li   $t1, 45              # col

li   $t2, 0
S_top_loop:
    bge  $t2, 8, S_top_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    S_top_loop
S_top_done:

li   $t0, 41
S_upper_vert:
    bgt  $t0, 44, S_upper_vert_done
    mul  $t4, $t0, 512
    mul  $t5, $t1, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    S_upper_vert
S_upper_vert_done:

li   $t0, 45
li   $t2, 0
S_mid_loop:
    bge  $t2, 8, S_mid_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    S_mid_loop
S_mid_done:

li   $t0, 46
li   $t1, 52
S_lower_vert:
    bgt  $t0, 50, S_lower_vert_done
    mul  $t4, $t0, 512
    mul  $t5, $t1, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    S_lower_vert
S_lower_vert_done:

li   $t0, 51
li   $t1, 45
li   $t2, 0
S_bottom_loop:
    bge  $t2, 8, S_bottom_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    S_bottom_loop
S_bottom_done:

# ========== Big "T" ==========
li   $t0, 40
li   $t1, 55
li   $t2, 0
T_top_loop:
    bge  $t2, 8, T_top_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    T_top_loop
T_top_done:

li   $t7, 3
add  $t8, $t1, $t7        # center col = 58
li   $t0, 41
T_vert_loop:
    bgt  $t0, 51, T_vert_done
    mul  $t4, $t0, 512
    mul  $t5, $t8, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    T_vert_loop
T_vert_done:

# ========== Big "A" ==========
li   $t0, 40
li   $t1, 65
li   $t2, 0
A_top_loop:
    bge  $t2, 8, A_top_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    A_top_loop
A_top_done:

li   $t0, 41
A_left_vert:
    bgt  $t0, 51, A_left_done
    mul  $t4, $t0, 512
    li   $t7, 65
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    A_left_vert
A_left_done:

li   $t0, 41
A_right_vert:
    bgt  $t0, 51, A_right_done
    mul  $t4, $t0, 512
    li   $t7, 72
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    A_right_vert
A_right_done:

li   $t0, 46
li   $t2, 0
A_cross_loop:
    bge  $t2, 8, A_cross_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    A_cross_loop
A_cross_done:

# ========== Big "R" ==========
li   $t0, 40
li   $t1, 75
li   $t2, 0
R_top_loop:
    bge  $t2, 6, R_top_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    R_top_loop
R_top_done:

li   $t0, 40
R_left_vert:
    bgt  $t0, 51, R_left_done
    mul  $t4, $t0, 512
    mul  $t5, $t1, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    R_left_vert
R_left_done:

li   $t0, 41
li   $t7, 81
R_top_right_vert:
    bgt  $t0, 44, R_top_right_done
    mul  $t4, $t0, 512
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    R_top_right_vert
R_top_right_done:

li   $t0, 45
li   $t2, 0
R_cross_loop:
    bge  $t2, 6, R_cross_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    R_cross_loop
R_cross_done:

li   $t0, 46
li   $t7, 81
R_bottom_leg:
    bgt  $t0, 51, R_bottom_done
    mul  $t4, $t0, 512
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    R_bottom_leg
R_bottom_done:

# ========== Final "T" ==========
li   $t0, 40
li   $t1, 85
li   $t2, 0
T2_top_loop:
    bge  $t2, 8, T2_top_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    T2_top_loop
T2_top_done:

li   $t7, 3
add  $t8, $t1, $t7      # 85 + 3 = 88
li   $t0, 41
T2_vert_loop:
    bgt  $t0, 51, T2_vert_done
    mul  $t4, $t0, 512
    mul  $t5, $t8, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    T2_vert_loop
T2_vert_done:

# Draw white 3D cube at row 15, col 33 (above START and 30 cols right of original)
li $t9, 0x00FFFFFF          # White color

# -----------------------------
# Front face square (15,33)
# -----------------------------
# Top horizontal
li $t0, 15                  # row
li $t1, 33                  # col start
li $t2, 0
CubeFront_top:
    bge $t2, 10, CubeFront_top_done
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j CubeFront_top
CubeFront_top_done:

# Bottom horizontal
li $t0, 24
li $t2, 0
CubeFront_bottom:
    bge $t2, 10, CubeFront_bottom_done
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j CubeFront_bottom
CubeFront_bottom_done:

# Left vertical
li $t0, 15
li $t2, 0
CubeFront_left:
    bge $t2, 10, CubeFront_left_done
    add $t3, $t0, $t2
    mul $t4, $t3, 512
    mul $t5, $t1, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j CubeFront_left
CubeFront_left_done:

# Right vertical
li $t1, 42                 # 33 + 9
li $t0, 15
li $t2, 0
CubeFront_right:
    bge $t2, 10, CubeFront_right_done
    add $t3, $t0, $t2
    mul $t4, $t3, 512
    mul $t5, $t1, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j CubeFront_right
CubeFront_right_done:

# -----------------------------
# Back face square (18,37)
# -----------------------------
li $t0, 18
li $t1, 37
li $t2, 0
CubeBack_top:
    bge $t2, 10, CubeBack_top_done
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j CubeBack_top
CubeBack_top_done:

# Back bottom
li $t0, 27
li $t2, 0
CubeBack_bottom:
    bge $t2, 10, CubeBack_bottom_done
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j CubeBack_bottom
CubeBack_bottom_done:

# Back left vertical
li $t0, 18
li $t2, 0
CubeBack_left:
    bge $t2, 10, CubeBack_left_done
    add $t3, $t0, $t2
    mul $t4, $t3, 512
    li  $t1, 37
    mul $t5, $t1, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j CubeBack_left
CubeBack_left_done:

# Back right vertical
li $t0, 18
li $t2, 0
CubeBack_right:
    bge $t2, 10, CubeBack_right_done
    add $t3, $t0, $t2
    mul $t4, $t3, 512
    li  $t1, 46              # 37 + 9
    mul $t5, $t1, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j CubeBack_right
CubeBack_right_done:

# -----------------------------
# Diagonal 1: top-left (15,33) -> (18,37)
li $t2, 0
CubeDiag1:
    bge $t2, 4, CubeDiag1_done
    addi $t3, $t2, 15
    addi $t4, $t2, 33
    mul  $t5, $t3, 512
    mul  $t6, $t4, 4
    add  $t7, $s0, $t5
    add  $t7, $t7, $t6
    sw   $t9, 0($t7)
    addi $t2, $t2, 1
    j CubeDiag1
CubeDiag1_done:

# Diagonal 2: top-right (15,42) -> (18,46)
li $t2, 0
CubeDiag2:
    bge $t2, 4, CubeDiag2_done
    addi $t3, $t2, 15
    addi $t4, $t2, 42
    mul  $t5, $t3, 512
    mul  $t6, $t4, 4
    add  $t7, $s0, $t5
    add  $t7, $t7, $t6
    sw   $t9, 0($t7)
    addi $t2, $t2, 1
    j CubeDiag2
CubeDiag2_done:

# Diagonal 3: bottom-left (24,33) -> (27,37)
li $t2, 0
CubeDiag3:
    bge $t2, 4, CubeDiag3_done
    addi $t3, $t2, 24
    addi $t4, $t2, 33
    mul  $t5, $t3, 512
    mul  $t6, $t4, 4
    add  $t7, $s0, $t5
    add  $t7, $t7, $t6
    sw   $t9, 0($t7)
    addi $t2, $t2, 1
    j CubeDiag3
CubeDiag3_done:

# Diagonal 4: bottom-right (24,42) -> (27,46)
li $t2, 0
CubeDiag4:
    bge $t2, 4, CubeDiag4_done
    addi $t3, $t2, 24
    addi $t4, $t2, 42
    mul  $t5, $t3, 512
    mul  $t6, $t4, 4
    add  $t7, $s0, $t5
    add  $t7, $t7, $t6
    sw   $t9, 0($t7)
    addi $t2, $t2, 1
    j CubeDiag4
CubeDiag4_done:

# -----------------------------
# Draw W A R S beside the cube starting at row 15, col 50

# ---- Draw W (row 15, col 50) ----
li $t0, 15
li $t1, 50
li $t2, 0
W_left:
    bge $t2, 12, W_left_done
    add $t3, $t0, $t2
    mul $t4, $t3, 512
    mul $t5, $t1, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j W_left
W_left_done:

li $t2, 0
W_right:
    bge $t2, 12, W_right_done
    add $t3, $t0, $t2
    li $t7, 57
    mul $t4, $t3, 512
    mul $t5, $t7, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j W_right
W_right_done:

# W diagonal left-to-center (row 25 to 27, cols 51 to 53)
li $t2, 0
W_diag_left:
    bge $t2, 3, W_diag_left_done
    addi $t3, $t2, 25      # row = 25 + t2
    addi $t4, $t2, 54      # col = 51 + t2
    mul  $t5, $t3, 512
    mul  $t6, $t4, 4
    add  $t7, $s0, $t5
    add  $t7, $t7, $t6
    sw   $t9, 0($t7)
    addi $t2, $t2, 1
    j W_diag_left
W_diag_left_done:

# W diagonal right-to-center (row 25 to 27, cols 56 to 54)
li $t2, 0
W_diag_right:
    bge $t2, 3, W_diag_right_done
    addi $t3, $t2, 25      # row = 25 + t2
    li   $t4, 53
    sub  $t4, $t4, $t2     # col = 56 - t2
    mul  $t5, $t3, 512
    mul  $t6, $t4, 4
    add  $t7, $s0, $t5
    add  $t7, $t7, $t6
    sw   $t9, 0($t7)
    addi $t2, $t2, 1
    j W_diag_right
W_diag_right_done:

# ---- Draw A (row 15, col 60) ----
li $t0, 15
li $t1, 60
li $t2, 0
A_top_loop2:
    bge $t2, 8, A_top_done2
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j A_top_loop2
A_top_done2:

li $t0, 16
A_left_vert2:
    bgt $t0, 26, A_left_done2
    mul $t4, $t0, 512
    li $t7, 60
    mul $t5, $t7, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t0, $t0, 1
    j A_left_vert2
A_left_done2:

li $t0, 16
A_right_vert2:
    bgt $t0, 26, A_right_done2
    mul $t4, $t0, 512
    li $t7, 67
    mul $t5, $t7, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t0, $t0, 1
    j A_right_vert2
A_right_done2:

li $t0, 21
li $t2, 0
A_cross2:
    bge $t2, 8, A_cross_done2
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j A_cross2
A_cross_done2:

# ---- Draw R (row 15, col 70) ----
li   $t0, 15
li   $t1, 70
li   $t2, 0
R_top_loop1:
    bge  $t2, 6, R_top_done1
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    R_top_loop1
R_top_done1:

li   $t0, 15
R_left_vert1:
    bgt  $t0, 26, R_left_done1
    mul  $t4, $t0, 512
    mul  $t5, $t1, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    R_left_vert1
R_left_done1:

li   $t0, 16
li   $t7, 76
R_top_right_vert1:
    bgt  $t0, 19, R_top_right_done1
    mul  $t4, $t0, 512
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    R_top_right_vert1
R_top_right_done1:

li   $t0, 20
li   $t2, 0
R_cross_loop1:
    bge  $t2, 6, R_cross_done1
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    R_cross_loop1
R_cross_done1:

li   $t0, 21
li   $t7, 76
R_bottom_leg1:
    bgt  $t0, 26, R_bottom_done1
    mul  $t4, $t0, 512
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    R_bottom_leg1
R_bottom_done1:

# ---- Draw S (row 15, col 80) ----
li $t0, 15
li $t1, 80
li $t2, 0
S_top1:
    bge $t2, 8, S_top_done1
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j S_top1
S_top_done1:

# Upper vertical (left side)
li $t0, 16
S_upper_vert1:
    bgt $t0, 19, S_upper_vert_done1
    mul $t4, $t0, 512
    mul $t5, $t1, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t0, $t0, 1
    j S_upper_vert1
S_upper_vert_done1:

# Middle horizontal
li $t0, 20
li $t2, 0
S_mid1:
    bge $t2, 8, S_mid_done1
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j S_mid1
S_mid_done1:

# Lower vertical (right side)
li $t0, 21
li $t7, 87
S_lower_vert1:
    bgt $t0, 24, S_lower_vert_done1
    mul $t4, $t0, 512
    mul $t5, $t7, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t0, $t0, 1
    j S_lower_vert1
S_lower_vert_done1:

# Bottom horizontal
li $t0, 25
li $t1, 80
li $t2, 0
S_bottom1:
    bge $t2, 8, S_bottom_done1
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j S_bottom1
S_bottom_done1:


start_input_loop:
    li   $t0, 0xffff0000      # Keyboard MMIO base address
wait_for_key:
    lw   $t1, 0($t0)          # Read key status
    beq  $t1, $zero, wait_for_key  # No key pressed, wait
    lw   $t2, 4($t0)          # Read ASCII code of key pressed
    li   $t3, 115             # ASCII for 's'
    beq  $t2, $t3, start_game  # If 's' pressed, start the game
    li   $t3, 114             # ASCII for 'r'
    beq  $t2, $t3, restart_game  # If 'r' pressed, restart the game
    li   $t3, 113             # ASCII for 'q'
    beq  $t2, $t3, restart_start_screen  # Optionally keep this for a restart of the start screen
    j wait_for_key            # For any other key, keep waiting



start_game:
    jr $ra                    # Return to caller (main continues to main_game_loop)

restart_start_screen:
    # Clear key buffer
    li   $t0, 0xffff0000
clear_key_buffer:
    lw   $t1, 0($t0)          # Read key status
    beq  $t1, $zero, restart_start_screen_continue
    lw   $t2, 4($t0)          # Read ASCII code to clear buffer
    j    clear_key_buffer

restart_start_screen_continue:
    jal start_screen
    j start_input_loop
