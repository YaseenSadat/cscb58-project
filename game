#####################################################################
#
# CSCB58 Winter 2025 Assembly Final Project
# University of Toronto, Scarborough
#
# Student: Yaseen Sadat, 1010358596, sadatyas, yaseen.sadat@mail.utoronto.ca
#
# Bitmap Display Configuration:
# - Unit width in pixels: 4
# - Unit height in pixels: 4
# - Display width in pixels: 512
# - Display height in pixels: 256
# - Base Address for Display: 0x10008000 ($gp)
#
# Milestones reached:
# - Milestone 1
#
# Approved features for Milestone 3:
# 1. Player now has a 4x4 sprite with eyes that differ based on facing:
#    - Right facing (player_facing==0): eyes at (row1, col1) and (row1, col3)
#    - Left facing  (player_facing==1): eyes at (row1, col0) and (row1, col2)
#
# 2. Floating Platform Collision (one-way):
#    - Platform A (row 50, cols 10 to 30) now collides with the player only when
#      falling from above. If the player's bottom (player_row+3) goes from above row 50
#      to row 50 or below and the player horizontally overlaps the platform,
#      the player is set to stand on the platform (player_row = 46).
#
# Additional information:
# - Step-by-step build in progress
#
#####################################################################

.eqv BASE_ADDRESS 0x10008000    # Framebuffer base address

.data
# Player position and physics variables
player_row:      .word 60        # Y-position (row)
player_col:      .word 2         # X-position (column)
player_velocity: .word 0         # Y velocity (positive = falling, negative = jumping up)
is_jumping:      .word 0         # 1 if in the air, 0 if grounded

# New variable to indicate facing direction: 0 = right, 1 = left
player_facing:   .word 0

# Temporary storage for the current player's base position
current_player_row: .word 0
current_player_col: .word 0

# Buffer to store the 4×4 background region under the player (16 words = 64 bytes)
player_bg_buffer: .space 64

# Movement delay variables
move_delay_counter: .word 0    # Countdown counter to control repeat movement
move_delay_value:   .word 2    # Delay constant (adjust for speed)

# Multi-shade reds for a more detailed red planet (top left)
darkest_red:   .word 0x008B0000   # Dark red
dark_red:      .word 0x00B22222   # Firebrick
mid_red:       .word 0x00CD5C5C   # IndianRed
light_red:     .word 0x00FA8072   # Salmon

# Define black color for facial features
black: .word 0x00000000

# -------------------------------------------------------------------
# Earth planet colors (for an Earth‐like planet, top right):
#   - earth_dark:    dark ocean
#   - earth_ocean:   bright ocean blue
#   - earth_land:    green (land)
#   - earth_clouds:  white (clouds)
# -------------------------------------------------------------------
earth_dark:    .word 0x00004080   # Dark ocean (R=0, G=64, B=128)
earth_ocean:   .word 0x000080FF   # Ocean blue (R=0, G=128, B=255)
earth_land:    .word 0x00008000   # Land green (R=0, G=128, B=0)
earth_clouds:  .word 0x00FFFFFF   # Clouds (white)

.text
main:
    ################################################################
    # START SCREEN
    ################################################################
    jal start_screen       # Call the start screen subroutine

main_game_loop:
    ################################################################
    # INITIALIZE CONSTANTS
    ################################################################
    li   $s0, BASE_ADDRESS        # Framebuffer base address
    li   $s1, 0x00808080          # Grey color for platforms
    li   $s2, 0x00FF0000          # Red color for player
    li   $s3, 0x00000080          # Dark blue background

    ################################################################
    # DRAW BACKGROUND (64 rows × 128 cols)
    ################################################################
    li   $t4, 0                 # row = 0
bg_row_loop:
    li   $t5, 0                 # col = 0
bg_col_loop:
    mul  $t6, $t4, 512          # row offset (512 bytes per row)
    mul  $t7, $t5, 4            # column offset (4 bytes per pixel)
    add  $t8, $s0, $t6          # base address + row offset
    add  $t8, $t8, $t7          # + column offset
    sw   $s3, 0($t8)            # set pixel to dark blue
    addi $t5, $t5, 1
    blt  $t5, 128, bg_col_loop
    addi $t4, $t4, 1
    blt  $t4, 64, bg_row_loop

################################################################
# DRAW STARS (plus-shaped, 4x4 pixel stars, each row has unique spacing)
################################################################

# Row 1
li $s4, 4
li $s5, 4
li $t8, 20
jal draw_star_row

# Row 2
li $s4, 20
li $s5, 10
li $t8, 15
jal draw_star_row

# Row 3
li $s4, 36
li $s5, 2
li $t8, 20
jal draw_star_row

# Row 4
li $s4, 52
li $s5, 8
li $t8, 18
jal draw_star_row

j stars_done

################################################################
# Subroutine: draw_star_row
# $s4 = fixed row, $s5 = starting col, $t8 = column gap
################################################################
draw_star_row:
    li $t0, 124              # Max col
    move $t7, $s5            # current star col

next_star:
    bgt $t7, $t0, end_star_row
    li  $t9, 0x00FFFF00      # Yellow color

    # Draw vertical line (center of plus)
    li   $t1, 0
draw_v:
    bgt  $t1, 2, done_v
    add  $t2, $s4, $t1        # row = base row + offset
    addi $t3, $t7, 1          # col = base col + 1
    mul  $t4, $t2, 512        # row offset
    mul  $t5, $t3, 4          # col offset
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t1, $t1, 1
    j draw_v
done_v:
    # Draw horizontal line (center of plus)
    li $t1, 0
draw_h:
    bgt  $t1, 2, done_h
    addi $t2, $s4, 1          # fixed center row
    add  $t3, $t7, $t1        # col = base col + offset
    mul  $t4, $t2, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t1, $t1, 1
    j draw_h
done_h:
    add $t7, $t7, $t8         # next star col
    j next_star
end_star_row:
    jr $ra

stars_done:

    ################################################################
    # DRAW RED PLANET (TOP LEFT, swirl pattern)
    ################################################################
    li   $t0, 2         # red planet base row
    li   $t1, 2         # red planet base col
    li   $t2, 24        # bounding box size
    li   $t3, 12        # radius
    addu $t8, $t1, $t3  # center_col = base col + 12
    addu $t9, $t0, $t3  # center_row = base row + 12
    li   $t4, 0         # Outer loop counter (i)
planet_row_loop:
    bge  $t4, $t2, planet_done
    addu $t6, $t0, $t4      # current_row = base row + i
    li   $t5, 0           # Inner loop counter (j)
planet_col_loop:
    bge  $t5, $t2, planet_next_row
    addu $t7, $t1, $t5      # current_col = base col + j
    sub  $a0, $t7, $t8      # dx = current_col - center_col
    sub  $a1, $t6, $t9      # dy = current_row - center_row
    mul  $v1, $a0, $a0      # dx^2
    mul  $t3, $a1, $a1      # dy^2 (temporary)
    addu $v1, $v1, $t3      # distance^2
    li   $t3, 144          # 12^2 = 144
    bgt  $v1, $t3, planet_skip_pixel
    sll  $v0, $a1, 1       # pattern: (2*dy + dx) >> 2
    addu $v0, $v0, $a0
    sra  $v0, $v0, 2
    andi $v0, $v0, 3      # mod 4
    li   $t3, 0
    beq  $v0, $zero, pick_darkest
    li   $t3, 1
    beq  $v0, $t3, pick_dark
    li   $t3, 2
    beq  $v0, $t3, pick_mid
pick_light:
    lw   $t3, light_red
    j    planet_set_pixel
pick_mid:
    lw   $t3, mid_red
    j    planet_set_pixel
pick_dark:
    lw   $t3, dark_red
    j    planet_set_pixel
pick_darkest:
    lw   $t3, darkest_red
planet_set_pixel:
    mul  $v1, $t6, 512         # row offset in bytes
    sll  $a0, $t7, 2           # col offset in bytes
    addu $v1, $s0, $v1        # base + row offset
    addu $v1, $v1, $a0        # final pixel address
    sw   $t3, 0($v1)          # store chosen red color
planet_skip_pixel:
    addi $t5, $t5, 1         # j++
    j    planet_col_loop
planet_next_row:
    addi $t4, $t4, 1         # i++
    j    planet_row_loop
planet_done:

    ################################################################
    # DRAW EARTH-LIKE PLANET (TOP RIGHT, swirl pattern)
    ################################################################
    li   $t0, 12         # earth planet base row
    li   $t1, 102       # earth planet base col
    li   $t2, 24        # bounding box size
    li   $t3, 12        # radius
    addu $t8, $t1, $t3  # center_col = base col + 12
    addu $t9, $t0, $t3  # center_row = base row + 12
    li   $t4, 0         # Outer loop counter (i)
earth_row_loop:
    bge  $t4, $t2, earth_done
    addu $t6, $t0, $t4      # current_row = base row + i
    li   $t5, 0           # Inner loop counter (j)
earth_col_loop:
    bge  $t5, $t2, earth_next_row
    addu $t7, $t1, $t5      # current_col = base col + j
    sub  $a0, $t7, $t8      # dx = current_col - center_col
    sub  $a1, $t6, $t9      # dy = current_row - center_row
    mul  $v1, $a0, $a0      # dx^2
    mul  $t3, $a1, $a1      # dy^2 (temporary)
    addu $v1, $v1, $t3      # distance^2
    li   $t3, 144          # 12^2 = 144
    bgt  $v1, $t3, earth_skip_pixel
    sll  $v0, $a1, 1       # pattern: (2*dy + dx) >> 2
    addu $v0, $v0, $a0
    sra  $v0, $v0, 2
    andi $v0, $v0, 3      # mod 4
    li   $t3, 0
    beq  $v0, $zero, pick_earth_dark
    li   $t3, 1
    beq  $v0, $t3, pick_earth_ocean
    li   $t3, 2
    beq  $v0, $t3, pick_earth_land
pick_earth_clouds:
    lw   $t3, earth_clouds
    j    earth_set_pixel
pick_earth_land:
    lw   $t3, earth_land
    j    earth_set_pixel
pick_earth_ocean:
    lw   $t3, earth_ocean
    j    earth_set_pixel
pick_earth_dark:
    lw   $t3, earth_dark
earth_set_pixel:
    mul  $v1, $t6, 512      # row offset in bytes
    sll  $a0, $t7, 2        # col offset in bytes
    addu $v1, $s0, $v1      # base address
    addu $v1, $v1, $a0      # final pixel address
    sw   $t3, 0($v1)        # store chosen earth color
earth_skip_pixel:
    addi $t5, $t5, 1       # j++
    j    earth_col_loop
earth_next_row:
    addi $t4, $t4, 1       # i++
    j    earth_row_loop
earth_done:

################################################################
# DRAW PLATFORMS (A–E)
################################################################
li $t9, 0x00808080       # Grey color

# Platform A: row 50, columns 10 to 30 (floating platform)
li $t4, 50
li $t5, 10
platA_loop:
    mul $t6, $t4, 512
    mul $t7, $t5, 4
    add $t8, $s0, $t6
    add $t8, $t8, $t7
    sw  $t9, 0($t8)
    addi $t5, $t5, 1
    blt  $t5, 31, platA_loop

# Platform B: row 40, columns 40 to 70
li $t4, 40
li $t5, 40
platB_loop:
    mul $t6, $t4, 512
    mul $t7, $t5, 4
    add $t8, $s0, $t6
    add $t8, $t8, $t7
    sw  $t9, 0($t8)
    addi $t5, $t5, 1
    blt  $t5, 71, platB_loop

# Platform C: row 30, columns 80 to 105
li $t4, 30
li $t5, 80
platC_loop:
    mul $t6, $t4, 512
    mul $t7, $t5, 4
    add $t8, $s0, $t6
    add $t8, $t8, $t7
    sw  $t9, 0($t8)
    addi $t5, $t5, 1
    blt  $t5, 106, platC_loop

# Platform D: row 25, columns 20 to 45
li $t4, 25
li $t5, 20
platD_loop:
    mul $t6, $t4, 512
    mul $t7, $t5, 4
    add $t8, $s0, $t6
    add $t8, $t8, $t7
    sw  $t9, 0($t8)
    addi $t5, $t5, 1
    blt  $t5, 46, platD_loop

# Platform E: row 45, columns 95 to 120
li $t4, 45
li $t5, 95
platE_loop:
    mul $t6, $t4, 512
    mul $t7, $t5, 4
    add $t8, $s0, $t6
    add $t8, $t8, $t7
    sw  $t9, 0($t8)
    addi $t5, $t5, 1
    blt  $t5, 121, platE_loop

    ################################################################
    # INIT PREVIOUS PLAYER POSITION
    ################################################################
    li   $s6, 60
    li   $s7, 2

######################################################################
# MAIN GAME LOOP
######################################################################
game_loop:
    ################################################################
    # 1) Handle Continuous Input with Delay
    ################################################################
    li   $t0, 0xffff0000      # Keyboard MMIO base
    lw   $t1, 0($t0)          # Read key status
    beq  $t1, $zero, reset_delay   # No key pressed: reset delay counter

    lw   $t2, move_delay_counter   # Load delay counter
    bnez $t2, decrement_delay       # If counter is not zero, skip input

    # A key is pressed and delay counter is 0; process input:
    lw   $t3, 4($t0)          # ASCII code
    li   $t4, 97              # 'a'
    beq  $t3, $t4, move_left
    li   $t4, 100             # 'd'
    beq  $t3, $t4, move_right
    li   $t4, 119             # 'w'
    beq  $t3, $t4, try_jump

go_to_start_screen:
    jal start_screen      # Go to start screen
    # After returning from start screen, reset state:
    li   $t0, 60          # initial player_row
    sw   $t0, player_row
    li   $t0, 2           # initial player_col
    sw   $t0, player_col
    li   $t0, 0           # reset player_velocity
    sw   $t0, player_velocity
    li   $t0, 0           # reset is_jumping
    sw   $t0, is_jumping
    j game_loop           # Jump back into the game loop


decrement_delay:
    lw   $t2, move_delay_counter
    addi $t2, $t2, -1
    sw   $t2, move_delay_counter
reset_delay:
    # If no key is pressed, reset the counter to 0
    li   $t2, 0
    sw   $t2, move_delay_counter
    j skip_input

skip_input:
    ################################################################
    # 2) Restore Old Player Background from Buffer
    # (Iterate 4 rows × 4 cols)
    ################################################################
    la   $t3, player_bg_buffer
    li   $t8, 0
restore_bg_loop_rows:
    li   $t9, 0
restore_bg_loop_cols:
    add  $t4, $s6, $t8
    add  $t5, $s7, $t9
    mul  $t4, $t4, 512
    mul  $t5, $t5, 4
    add  $t0, $s0, $t4
    add  $t0, $t0, $t5
    lw   $t1, 0($t3)
    sw   $t1, 0($t0)
    addi $t3, $t3, 4
    addi $t9, $t9, 1
    blt  $t9, 4, restore_bg_loop_cols
    addi $t8, $t8, 1
    blt  $t8, 4, restore_bg_loop_rows

    ################################################################
    # 3) Apply Gravity (with floating platform collision)
    ################################################################
    jal  apply_gravity

    ################################################################
    # 4) Clamp & Save New Player Position
    # (Max row = 60, max col = 124 for 4x4 sprite)
    ################################################################
    la   $t0, player_row
    la   $t1, player_col
    lw   $t4, 0($t0)
    lw   $t5, 0($t1)
    li   $t6, 0
    blt  $t4, $t6, fix_top
    li   $t6, 60
    bgt  $t4, $t6, fix_bottom
    j    skip_row_clamp
fix_top:
    li   $t4, 0
    sw   $t4, player_row
    j    skip_row_clamp
fix_bottom:
    li   $t4, 60
    sw   $t4, player_row
skip_row_clamp:

    li   $t6, 0
    blt  $t5, $t6, fix_left
    li   $t6, 124
    bgt  $t5, $t6, fix_right
    j    skip_col_clamp
fix_left:
    li   $t5, 0
    sw   $t5, player_col
    j    skip_col_clamp
fix_right:
    li   $t5, 124
    sw   $t5, player_col
skip_col_clamp:

    lw   $t5, 0($t1)
    la   $t7, current_player_row
    sw   $t4, 0($t7)
    la   $t7, current_player_col
    sw   $t5, 0($t7)

    ################################################################
    # 5) Save New Background into Buffer
    # (Iterate 4 rows x 4 cols)
    ################################################################
    la   $t3, player_bg_buffer
    li   $t8, 0
save_bg_loop_rows:
    la   $t7, current_player_row
    lw   $t5, 0($t7)
    la   $t7, current_player_col
    lw   $t6, 0($t7)
    li   $t9, 0
save_bg_loop_cols:
    add  $t2, $t5, $t8
    add  $t1, $t6, $t9
    mul  $t2, $t2, 512
    mul  $t1, $t1, 4
    add  $t0, $s0, $t2
    add  $t0, $t0, $t1
    lw   $t4, 0($t0)
    sw   $t4, 0($t3)
    addi $t3, $t3, 4
    addi $t9, $t9, 1
    blt  $t9, 4, save_bg_loop_cols
    addi $t8, $t8, 1
    blt  $t8, 4, save_bg_loop_rows

    ################################################################
    # 6) Draw Player at New Position (4x4 sprite with eyes)
    ################################################################
    li   $t8, 0            # Row offset (0..3)
draw_loop_rows:
    la   $t7, current_player_row
    lw   $t5, 0($t7)       # Base row for player
    la   $t7, current_player_col
    lw   $t6, 0($t7)       # Base col for player
    li   $t9, 0            # Column offset (0..3)
draw_loop_cols:
    add  $t2, $t5, $t8     # current_row = base_row + row offset
    add  $t1, $t6, $t9     # current_col = base_col + col offset
    mul  $t2, $t2, 512     # row offset in bytes
    mul  $t1, $t1, 4       # col offset in bytes
    add  $t0, $s0, $t2     # pixel address = base + row offset
    add  $t0, $t0, $t1     # + column offset

    # Determine pixel color.
    # For all rows except row 1, draw red ($s2).
    # For row 1, choose eye color based on facing.
    li   $t3, 1
    bne  $t8, $t3, player_set_red   # if row offset != 1, set red

    # Now in row 1: load player_facing.
    lw   $t3, player_facing         # $t3 = 0 for right, 1 for left
    beq  $t3, $zero, right_facing    # if facing == 0, branch to right_facing

    # Left facing branch:
left_facing:
    li   $t4, 0
    beq  $t9, $t4, player_set_black  # if col offset == 0, set black
    li   $t4, 2
    beq  $t9, $t4, player_set_black  # if col offset == 2, set black
    j    player_set_red

right_facing:
    li   $t4, 1
    beq  $t9, $t4, player_set_black  # if col offset == 1, set black
    li   $t4, 3
    beq  $t9, $t4, player_set_black  # if col offset == 3, set black
    j    player_set_red

player_set_black:
    lw   $t7, black       # load black color
    j    store_pixel
player_set_red:
    move $t7, $s2         # set red color
store_pixel:
    sw   $t7, 0($t0)      # write chosen color

    addi $t9, $t9, 1
    blt  $t9, 4, draw_loop_cols
    addi $t8, $t8, 1
    blt  $t8, 4, draw_loop_rows

    ################################################################
    # 7) Update Previous Player Position
    ################################################################
    la   $t7, current_player_row
    lw   $t4, 0($t7)
    move $s6, $t4
    la   $t7, current_player_col
    lw   $t4, 0($t7)
    move $s7, $t4

    ################################################################
    # 8) Frame Delay
    ################################################################
    li   $v0, 32
    li   $a0, 40
    syscall

    j game_loop

######################################################################
# INPUT HANDLERS
######################################################################
move_left:
    lw   $t4, player_col
    li   $t5, 2
    ble  $t4, $t5, done_moving   # Prevent moving left if at or below boundary
    addi $t4, $t4, -4            # Subtract 2 units => 2*4 = 8 pixels
    sw   $t4, player_col
    # Set facing to left (1)
    li   $t6, 1
    sw   $t6, player_facing
done_moving:
    lw   $t7, move_delay_value
    sw   $t7, move_delay_counter
    j skip_input

move_right:
    lw   $t4, player_col
    li   $t5, 124
    bge  $t4, $t5, done_moving2  # Prevent moving right if at or beyond boundary
    addi $t4, $t4, 4             # Add 2 units => 2*4 = 8 pixels
    sw   $t4, player_col
    # Set facing to right (0)
    li   $t6, 0
    sw   $t6, player_facing
done_moving2:
    lw   $t7, move_delay_value
    sw   $t7, move_delay_counter
    j skip_input

try_jump:
    la   $t0, is_jumping
    lw   $t1, 0($t0)
    bnez $t1, game_loop
    li   $t1, 1
    sw   $t1, 0($t0)
    la   $t2, player_velocity
    li   $t3, -6
    sw   $t3, 0($t2)
    lw   $t7, move_delay_value
    sw   $t7, move_delay_counter
    j skip_input

######################################################################
# GRAVITY ENGINE (platform is fully solid: no climbing from below)
######################################################################
apply_gravity:
    la   $t0, is_jumping
    lw   $t1, 0($t0)
    la   $t2, player_row
    lw   $t3, 0($t2)       # old player row in $t3
    la   $t4, player_velocity
    lw   $t5, 0($t4)       # current velocity in $t5
    bnez $t1, apply_physics
    li   $t6, 60          # floor: max row = 60
    beq  $t3, $t6, done_gravity
    li   $t1, 1
    sw   $t1, 0($t0)
    li   $t5, 1
    sw   $t5, 0($t4)
    j    apply_physics

apply_physics:
    move $t6, $t3         # save old row in $t6
    add  $t3, $t3, $t5    # new row = old row + velocity

    # For collision checks, compute bottoms:
    addi $t7, $t3, 3      # new_bottom = new row + 3
    addi $t9, $t6, 3      # old_bottom = old row + 3

    # Branch based on velocity:
    bgtz $t5, check_downward         # if falling (velocity > 0)
    bltz $t5, check_upward_A         # if jumping (velocity < 0)
    j no_platform_collision          # if velocity == 0

#---------------- Downward Collision for Platform A (row 50, cols 10–30) ----------------
check_downward:
    slti $s4, $t9, 50          # $s4 = 1 if old_bottom < 50
    slti $s5, $t7, 50          # $s5 = 1 if new_bottom < 50
    beq  $s4, $zero, check_platform_B  # if old_bottom not less than 50, go to next
    bnez $s5, check_platform_B          # if new_bottom still less than 50, no collision with A
    j    check_horizontal_A

check_horizontal_A:
    lw   $s6, player_col      # player's left col
    addi $t8, $s6, 3          # player's right col = left + 3
    li   $s7, 31              # if player's left col >= 31, no collision
    bge  $s6, $s7, check_platform_B
    li   $s7, 10              # platform A left boundary = 10
    blt  $t8, $s7, check_platform_B  # if player's right col < 10, no collision
    # Downward collision detected for Platform A: clamp player's row to 50 - 4 = 46
    li   $t3, 46
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

#---------------- Downward Collision for Platforms B–E ----------------
# (As in your previous code; unchanged from earlier snippet.)
check_platform_B:
    slti $s4, $t9, 40
    slti $s5, $t7, 40
    beq  $s4, $zero, check_platform_C
    bnez $s5, check_platform_C
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 71
    bge  $s6, $s7, check_platform_C
    li   $s7, 40
    blt  $t8, $s7, check_platform_C
    li   $t3, 36
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_platform_C:
    slti $s4, $t9, 30
    slti $s5, $t7, 30
    beq  $s4, $zero, check_platform_D
    bnez $s5, check_platform_D
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 106
    bge  $s6, $s7, check_platform_D
    li   $s7, 80
    blt  $t8, $s7, check_platform_D
    li   $t3, 26
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_platform_D:
    slti $s4, $t9, 25
    slti $s5, $t7, 25
    beq  $s4, $zero, check_platform_E
    bnez $s5, check_platform_E
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 46
    bge  $s6, $s7, check_platform_E
    li   $s7, 20
    blt  $t8, $s7, check_platform_E
    li   $t3, 21
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_platform_E:
    slti $s4, $t9, 45
    slti $s5, $t7, 45
    beq  $s4, $zero, no_platform_collision
    bnez $s5, no_platform_collision
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 121
    bge  $s6, $s7, no_platform_collision
    li   $s7, 95
    blt  $t8, $s7, no_platform_collision
    li   $t3, 41
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

#---------------- Upward Collision Checks for Platforms A–E ----------------
check_upward_A:
    # For upward collision on Platform A (row 50)
    ble  $t6, 50, check_upward_B  # if old top <= 50, no collision here
    bgt  $t3, 50, check_upward_B  # if new top > 50, no collision
    j    check_horizontal_up_A
check_horizontal_up_A:
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 31
    bge  $s6, $s7, check_upward_B
    li   $s7, 10
    blt  $t8, $s7, check_upward_B
    # Upward collision detected for Platform A: clamp player's row to 51
    li   $t3, 51
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_upward_B:
    # For upward collision on Platform B (row 40)
    ble  $t6, 40, check_upward_C
    bgt  $t3, 40, check_upward_C
    j    check_horizontal_up_B
check_horizontal_up_B:
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 71
    bge  $s6, $s7, check_upward_C
    li   $s7, 40
    blt  $t8, $s7, check_upward_C
    # Upward collision detected for Platform B: clamp player's row to 41
    li   $t3, 41
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_upward_C:
    # For upward collision on Platform C (row 30)
    ble  $t6, 30, check_upward_D
    bgt  $t3, 30, check_upward_D
    j    check_horizontal_up_C
check_horizontal_up_C:
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 106
    bge  $s6, $s7, check_upward_D
    li   $s7, 80
    blt  $t8, $s7, check_upward_D
    # Upward collision detected for Platform C: clamp player's row to 31
    li   $t3, 31
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_upward_D:
    # For upward collision on Platform D (row 25)
    ble  $t6, 25, check_upward_E
    bgt  $t3, 25, check_upward_E
    j    check_horizontal_up_D
check_horizontal_up_D:
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 46
    bge  $s6, $s7, check_upward_E
    li   $s7, 20
    blt  $t8, $s7, check_upward_E
    # Upward collision detected for Platform D: clamp player's row to 26
    li   $t3, 26
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_upward_E:
    # For upward collision on Platform E (row 45)
    ble  $t6, 45, no_platform_collision  # if old top <= 45, no upward collision
    bgt  $t3, 45, no_platform_collision  # if new top > 45, no collision
    j    check_horizontal_up_E
check_horizontal_up_E:
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 121
    bge  $s6, $s7, no_platform_collision
    li   $s7, 95
    blt  $t8, $s7, no_platform_collision
    # Upward collision detected for Platform E: clamp player's row to 46
    li   $t3, 46
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

# If no upward collision detected for any platform:
no_platform_collision:
    bgt  $t3, 60, set_floor
    sw   $t3, player_row
    addi $t5, $t5, 1
    sw   $t5, player_velocity

done_gravity:
    jr   $ra

set_floor:
    li   $t3, 60
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    jr   $ra

end:
    j end

########################################################################
# START SCREEN SUBROUTINE
########################################################################
start_screen:
    # Clear the display (64 rows x 128 cols) with dark blue ($s3)
    li   $s0, BASE_ADDRESS    # Ensure $s0 is set to the base address
    li   $s3, 0x00000080      # Dark blue background
    li   $t4, 0               # row counter (0 .. 63)
start_bg_row_loop:
    li   $t5, 0               # col counter (0 .. 127)
start_bg_col_loop:
    mul  $t6, $t4, 512        # compute row offset in bytes
    mul  $t7, $t5, 4          # compute col offset in bytes
    add  $t8, $s0, $t6        # base address + row offset
    add  $t8, $t8, $t7        # + col offset
    sw   $s3, 0($t8)          # set pixel to dark blue
    addi $t5, $t5, 1
    blt  $t5, 128, start_bg_col_loop
    addi $t4, $t4, 1
    blt  $t4, 64, start_bg_row_loop

# "START" title: shifted 15 columns right and 20 rows down (35 down - 15 up = net 20 rows)

# ========== Big "S" ==========
li   $t9, 0x00FFFFFF
li   $t0, 40              # row
li   $t1, 45              # col

li   $t2, 0
S_top_loop:
    bge  $t2, 8, S_top_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    S_top_loop
S_top_done:

li   $t0, 41
S_upper_vert:
    bgt  $t0, 44, S_upper_vert_done
    mul  $t4, $t0, 512
    mul  $t5, $t1, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    S_upper_vert
S_upper_vert_done:

li   $t0, 45
li   $t2, 0
S_mid_loop:
    bge  $t2, 8, S_mid_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    S_mid_loop
S_mid_done:

li   $t0, 46
li   $t1, 52
S_lower_vert:
    bgt  $t0, 50, S_lower_vert_done
    mul  $t4, $t0, 512
    mul  $t5, $t1, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    S_lower_vert
S_lower_vert_done:

li   $t0, 51
li   $t1, 45
li   $t2, 0
S_bottom_loop:
    bge  $t2, 8, S_bottom_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    S_bottom_loop
S_bottom_done:

# ========== Big "T" ==========
li   $t0, 40
li   $t1, 55
li   $t2, 0
T_top_loop:
    bge  $t2, 8, T_top_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    T_top_loop
T_top_done:

li   $t7, 3
add  $t8, $t1, $t7        # center col = 58
li   $t0, 41
T_vert_loop:
    bgt  $t0, 51, T_vert_done
    mul  $t4, $t0, 512
    mul  $t5, $t8, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    T_vert_loop
T_vert_done:

# ========== Big "A" ==========
li   $t0, 40
li   $t1, 65
li   $t2, 0
A_top_loop:
    bge  $t2, 8, A_top_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    A_top_loop
A_top_done:

li   $t0, 41
A_left_vert:
    bgt  $t0, 51, A_left_done
    mul  $t4, $t0, 512
    li   $t7, 65
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    A_left_vert
A_left_done:

li   $t0, 41
A_right_vert:
    bgt  $t0, 51, A_right_done
    mul  $t4, $t0, 512
    li   $t7, 72
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    A_right_vert
A_right_done:

li   $t0, 46
li   $t2, 0
A_cross_loop:
    bge  $t2, 8, A_cross_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    A_cross_loop
A_cross_done:

# ========== Big "R" ==========
li   $t0, 40
li   $t1, 75
li   $t2, 0
R_top_loop:
    bge  $t2, 6, R_top_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    R_top_loop
R_top_done:

li   $t0, 40
R_left_vert:
    bgt  $t0, 51, R_left_done
    mul  $t4, $t0, 512
    mul  $t5, $t1, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    R_left_vert
R_left_done:

li   $t0, 41
li   $t7, 81
R_top_right_vert:
    bgt  $t0, 44, R_top_right_done
    mul  $t4, $t0, 512
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    R_top_right_vert
R_top_right_done:

li   $t0, 45
li   $t2, 0
R_cross_loop:
    bge  $t2, 6, R_cross_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    R_cross_loop
R_cross_done:

li   $t0, 46
li   $t7, 81
R_bottom_leg:
    bgt  $t0, 51, R_bottom_done
    mul  $t4, $t0, 512
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    R_bottom_leg
R_bottom_done:

# ========== Final "T" ==========
li   $t0, 40
li   $t1, 85
li   $t2, 0
T2_top_loop:
    bge  $t2, 8, T2_top_done
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    T2_top_loop
T2_top_done:

li   $t7, 3
add  $t8, $t1, $t7      # 85 + 3 = 88
li   $t0, 41
T2_vert_loop:
    bgt  $t0, 51, T2_vert_done
    mul  $t4, $t0, 512
    mul  $t5, $t8, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    T2_vert_loop
T2_vert_done:

# Draw white 3D cube at row 15, col 33 (above START and 30 cols right of original)
li $t9, 0x00FFFFFF          # White color

# -----------------------------
# Front face square (15,33)
# -----------------------------
# Top horizontal
li $t0, 15                  # row
li $t1, 33                  # col start
li $t2, 0
CubeFront_top:
    bge $t2, 10, CubeFront_top_done
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j CubeFront_top
CubeFront_top_done:

# Bottom horizontal
li $t0, 24
li $t2, 0
CubeFront_bottom:
    bge $t2, 10, CubeFront_bottom_done
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j CubeFront_bottom
CubeFront_bottom_done:

# Left vertical
li $t0, 15
li $t2, 0
CubeFront_left:
    bge $t2, 10, CubeFront_left_done
    add $t3, $t0, $t2
    mul $t4, $t3, 512
    mul $t5, $t1, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j CubeFront_left
CubeFront_left_done:

# Right vertical
li $t1, 42                 # 33 + 9
li $t0, 15
li $t2, 0
CubeFront_right:
    bge $t2, 10, CubeFront_right_done
    add $t3, $t0, $t2
    mul $t4, $t3, 512
    mul $t5, $t1, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j CubeFront_right
CubeFront_right_done:

# -----------------------------
# Back face square (18,37)
# -----------------------------
li $t0, 18
li $t1, 37
li $t2, 0
CubeBack_top:
    bge $t2, 10, CubeBack_top_done
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j CubeBack_top
CubeBack_top_done:

# Back bottom
li $t0, 27
li $t2, 0
CubeBack_bottom:
    bge $t2, 10, CubeBack_bottom_done
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j CubeBack_bottom
CubeBack_bottom_done:

# Back left vertical
li $t0, 18
li $t2, 0
CubeBack_left:
    bge $t2, 10, CubeBack_left_done
    add $t3, $t0, $t2
    mul $t4, $t3, 512
    li  $t1, 37
    mul $t5, $t1, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j CubeBack_left
CubeBack_left_done:

# Back right vertical
li $t0, 18
li $t2, 0
CubeBack_right:
    bge $t2, 10, CubeBack_right_done
    add $t3, $t0, $t2
    mul $t4, $t3, 512
    li  $t1, 46              # 37 + 9
    mul $t5, $t1, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j CubeBack_right
CubeBack_right_done:

# -----------------------------
# Diagonal 1: top-left (15,33) -> (18,37)
li $t2, 0
CubeDiag1:
    bge $t2, 4, CubeDiag1_done
    addi $t3, $t2, 15
    addi $t4, $t2, 33
    mul  $t5, $t3, 512
    mul  $t6, $t4, 4
    add  $t7, $s0, $t5
    add  $t7, $t7, $t6
    sw   $t9, 0($t7)
    addi $t2, $t2, 1
    j CubeDiag1
CubeDiag1_done:

# Diagonal 2: top-right (15,42) -> (18,46)
li $t2, 0
CubeDiag2:
    bge $t2, 4, CubeDiag2_done
    addi $t3, $t2, 15
    addi $t4, $t2, 42
    mul  $t5, $t3, 512
    mul  $t6, $t4, 4
    add  $t7, $s0, $t5
    add  $t7, $t7, $t6
    sw   $t9, 0($t7)
    addi $t2, $t2, 1
    j CubeDiag2
CubeDiag2_done:

# Diagonal 3: bottom-left (24,33) -> (27,37)
li $t2, 0
CubeDiag3:
    bge $t2, 4, CubeDiag3_done
    addi $t3, $t2, 24
    addi $t4, $t2, 33
    mul  $t5, $t3, 512
    mul  $t6, $t4, 4
    add  $t7, $s0, $t5
    add  $t7, $t7, $t6
    sw   $t9, 0($t7)
    addi $t2, $t2, 1
    j CubeDiag3
CubeDiag3_done:

# Diagonal 4: bottom-right (24,42) -> (27,46)
li $t2, 0
CubeDiag4:
    bge $t2, 4, CubeDiag4_done
    addi $t3, $t2, 24
    addi $t4, $t2, 42
    mul  $t5, $t3, 512
    mul  $t6, $t4, 4
    add  $t7, $s0, $t5
    add  $t7, $t7, $t6
    sw   $t9, 0($t7)
    addi $t2, $t2, 1
    j CubeDiag4
CubeDiag4_done:

# -----------------------------
# Draw W A R S beside the cube starting at row 15, col 50

# ---- Draw W (row 15, col 50) ----
li $t0, 15
li $t1, 50
li $t2, 0
W_left:
    bge $t2, 12, W_left_done
    add $t3, $t0, $t2
    mul $t4, $t3, 512
    mul $t5, $t1, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j W_left
W_left_done:

li $t2, 0
W_right:
    bge $t2, 12, W_right_done
    add $t3, $t0, $t2
    li $t7, 57
    mul $t4, $t3, 512
    mul $t5, $t7, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j W_right
W_right_done:

# W diagonal left-to-center (row 25 to 27, cols 51 to 53)
li $t2, 0
W_diag_left:
    bge $t2, 3, W_diag_left_done
    addi $t3, $t2, 25      # row = 25 + t2
    addi $t4, $t2, 54      # col = 51 + t2
    mul  $t5, $t3, 512
    mul  $t6, $t4, 4
    add  $t7, $s0, $t5
    add  $t7, $t7, $t6
    sw   $t9, 0($t7)
    addi $t2, $t2, 1
    j W_diag_left
W_diag_left_done:

# W diagonal right-to-center (row 25 to 27, cols 56 to 54)
li $t2, 0
W_diag_right:
    bge $t2, 3, W_diag_right_done
    addi $t3, $t2, 25      # row = 25 + t2
    li   $t4, 53
    sub  $t4, $t4, $t2     # col = 56 - t2
    mul  $t5, $t3, 512
    mul  $t6, $t4, 4
    add  $t7, $s0, $t5
    add  $t7, $t7, $t6
    sw   $t9, 0($t7)
    addi $t2, $t2, 1
    j W_diag_right
W_diag_right_done:

# ---- Draw A (row 15, col 60) ----
li $t0, 15
li $t1, 60
li $t2, 0
A_top_loop2:
    bge $t2, 8, A_top_done2
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j A_top_loop2
A_top_done2:

li $t0, 16
A_left_vert2:
    bgt $t0, 26, A_left_done2
    mul $t4, $t0, 512
    li $t7, 60
    mul $t5, $t7, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t0, $t0, 1
    j A_left_vert2
A_left_done2:

li $t0, 16
A_right_vert2:
    bgt $t0, 26, A_right_done2
    mul $t4, $t0, 512
    li $t7, 67
    mul $t5, $t7, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t0, $t0, 1
    j A_right_vert2
A_right_done2:

li $t0, 21
li $t2, 0
A_cross2:
    bge $t2, 8, A_cross_done2
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j A_cross2
A_cross_done2:

# ---- Draw R (row 15, col 70) ----
li   $t0, 15
li   $t1, 70
li   $t2, 0
R_top_loop1:
    bge  $t2, 6, R_top_done1
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    R_top_loop1
R_top_done1:

li   $t0, 15
R_left_vert1:
    bgt  $t0, 26, R_left_done1
    mul  $t4, $t0, 512
    mul  $t5, $t1, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    R_left_vert1
R_left_done1:

li   $t0, 16
li   $t7, 76
R_top_right_vert1:
    bgt  $t0, 19, R_top_right_done1
    mul  $t4, $t0, 512
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    R_top_right_vert1
R_top_right_done1:

li   $t0, 20
li   $t2, 0
R_cross_loop1:
    bge  $t2, 6, R_cross_done1
    add  $t3, $t1, $t2
    mul  $t4, $t0, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t2, $t2, 1
    j    R_cross_loop1
R_cross_done1:

li   $t0, 21
li   $t7, 76
R_bottom_leg1:
    bgt  $t0, 26, R_bottom_done1
    mul  $t4, $t0, 512
    mul  $t5, $t7, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t0, $t0, 1
    j    R_bottom_leg1
R_bottom_done1:

# ---- Draw S (row 15, col 80) ----
li $t0, 15
li $t1, 80
li $t2, 0
S_top1:
    bge $t2, 8, S_top_done1
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j S_top1
S_top_done1:

# Upper vertical (left side)
li $t0, 16
S_upper_vert1:
    bgt $t0, 19, S_upper_vert_done1
    mul $t4, $t0, 512
    mul $t5, $t1, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t0, $t0, 1
    j S_upper_vert1
S_upper_vert_done1:

# Middle horizontal
li $t0, 20
li $t2, 0
S_mid1:
    bge $t2, 8, S_mid_done1
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j S_mid1
S_mid_done1:

# Lower vertical (right side)
li $t0, 21
li $t7, 87
S_lower_vert1:
    bgt $t0, 24, S_lower_vert_done1
    mul $t4, $t0, 512
    mul $t5, $t7, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t0, $t0, 1
    j S_lower_vert1
S_lower_vert_done1:

# Bottom horizontal
li $t0, 25
li $t1, 80
li $t2, 0
S_bottom1:
    bge $t2, 8, S_bottom_done1
    add $t3, $t1, $t2
    mul $t4, $t0, 512
    mul $t5, $t3, 4
    add $t6, $s0, $t4
    add $t6, $t6, $t5
    sw $t9, 0($t6)
    addi $t2, $t2, 1
    j S_bottom1
S_bottom_done1:


start_input_loop:
    li   $t0, 0xffff0000      # Keyboard MMIO base address
wait_for_key:
    lw   $t1, 0($t0)          # Read key status
    beq  $t1, $zero, wait_for_key  # No key pressed, wait
    lw   $t2, 4($t0)          # Read ASCII code of key pressed
    li   $t3, 115             # ASCII for 's'
    beq  $t2, $t3, start_game  # If 's' pressed, start the game
    li   $t3, 113             # ASCII for 'q'
    beq  $t2, $t3, restart_start_screen  # If 'q' pressed, restart the screen
    j wait_for_key            # For any other key, keep waiting

start_game:
    jr $ra                    # Return to caller (main continues to main_game_loop)

restart_start_screen:
    # Clear key buffer
    li   $t0, 0xffff0000
clear_key_buffer:
    lw   $t1, 0($t0)          # Read key status
    beq  $t1, $zero, restart_start_screen_continue
    lw   $t2, 4($t0)          # Read ASCII code to clear buffer
    j    clear_key_buffer

restart_start_screen_continue:
    jal start_screen
    j start_input_loop
