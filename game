#####################################################################
#
# CSCB58 Winter 2025 Assembly Final Project
# University of Toronto, Scarborough
#
# Student: Yaseen Sadat, 1010358596, sadatyas, yaseen.sadat@mail.utoronto.ca
#
# Bitmap Display Configuration:
# - Unit width in pixels: 4
# - Unit height in pixels: 4
# - Display width in pixels: 512
# - Display height in pixels: 256
# - Base Address for Display: 0x10008000 ($gp)
#
# Milestones reached:
# - Milestone 1
#
# Approved features for Milestone 3:
# 1. Player now has a 4x4 sprite with eyes that differ based on facing:
#    - Right facing (player_facing==0): eyes at (row1, col1) and (row1, col3)
#    - Left facing  (player_facing==1): eyes at (row1, col0) and (row1, col2)
#
# 2. Floating Platform Collision (one-way):
#    - Platform A (row 50, cols 10 to 30) now collides with the player only when
#      falling from above. If the player's bottom (player_row+3) goes from above row 50
#      to row 50 or below and the player horizontally overlaps the platform,
#      the player is set to stand on the platform (player_row = 46).
#
# Additional information:
# - Step-by-step build in progress
#
#####################################################################

.eqv BASE_ADDRESS 0x10008000    # Framebuffer base address

.data
# Player position and physics variables
player_row:      .word 60        # Y-position (row)
player_col:      .word 2         # X-position (column)
player_velocity: .word 0         # Y velocity (positive = falling, negative = jumping up)
is_jumping:      .word 0         # 1 if in the air, 0 if grounded

# New variable to indicate facing direction: 0 = right, 1 = left
player_facing:   .word 0

# Temporary storage for the current player's base position
current_player_row: .word 0
current_player_col: .word 0

# Buffer to store the 4×4 background region under the player (16 words = 64 bytes)
player_bg_buffer: .space 64

# Movement delay variables
move_delay_counter: .word 0    # Countdown counter to control repeat movement
move_delay_value:   .word 2    # Delay constant (adjust for speed)

# Multi-shade reds for a more detailed red planet (top left)
darkest_red:   .word 0x008B0000   # Dark red
dark_red:      .word 0x00B22222   # Firebrick
mid_red:       .word 0x00CD5C5C   # IndianRed
light_red:     .word 0x00FA8072   # Salmon

# Define black color for facial features
black: .word 0x00000000

# -------------------------------------------------------------------
# Earth planet colors (for an Earth‐like planet, top right):
#   - earth_dark:    dark ocean
#   - earth_ocean:   bright ocean blue
#   - earth_land:    green (land)
#   - earth_clouds:  white (clouds)
# -------------------------------------------------------------------
earth_dark:    .word 0x00004080   # Dark ocean (R=0, G=64, B=128)
earth_ocean:   .word 0x000080FF   # Ocean blue (R=0, G=128, B=255)
earth_land:    .word 0x00008000   # Land green (R=0, G=128, B=0)
earth_clouds:  .word 0x00FFFFFF   # Clouds (white)

.text
main:
    ################################################################
    # INITIALIZE CONSTANTS
    ################################################################
    li   $s0, BASE_ADDRESS        # Framebuffer base address
    li   $s1, 0x00808080          # Grey color for platforms
    li   $s2, 0x00FF0000          # Red color for player
    li   $s3, 0x00000080          # Dark blue background

    ################################################################
    # DRAW BACKGROUND (64 rows × 128 cols)
    ################################################################
    li   $t4, 0                 # row = 0
bg_row_loop:
    li   $t5, 0                 # col = 0
bg_col_loop:
    mul  $t6, $t4, 512          # row offset (512 bytes per row)
    mul  $t7, $t5, 4            # column offset (4 bytes per pixel)
    add  $t8, $s0, $t6          # base address + row offset
    add  $t8, $t8, $t7          # + column offset
    sw   $s3, 0($t8)            # set pixel to dark blue
    addi $t5, $t5, 1
    blt  $t5, 128, bg_col_loop
    addi $t4, $t4, 1
    blt  $t4, 64, bg_row_loop

################################################################
# DRAW STARS (plus-shaped, 4x4 pixel stars, each row has unique spacing)
################################################################

# Row 1
li $s4, 4
li $s5, 4
li $t8, 20
jal draw_star_row

# Row 2
li $s4, 20
li $s5, 10
li $t8, 15
jal draw_star_row

# Row 3
li $s4, 36
li $s5, 2
li $t8, 20
jal draw_star_row

# Row 4
li $s4, 52
li $s5, 8
li $t8, 18
jal draw_star_row

j stars_done

################################################################
# Subroutine: draw_star_row
# $s4 = fixed row, $s5 = starting col, $t8 = column gap
################################################################
draw_star_row:
    li $t0, 124              # Max col
    move $t7, $s5            # current star col

next_star:
    bgt $t7, $t0, end_star_row
    li  $t9, 0x00FFFF00      # Yellow color

    # Draw vertical line (center of plus)
    li   $t1, 0
draw_v:
    bgt  $t1, 2, done_v
    add  $t2, $s4, $t1        # row = base row + offset
    addi $t3, $t7, 1          # col = base col + 1
    mul  $t4, $t2, 512        # row offset
    mul  $t5, $t3, 4          # col offset
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t1, $t1, 1
    j draw_v
done_v:
    # Draw horizontal line (center of plus)
    li $t1, 0
draw_h:
    bgt  $t1, 2, done_h
    addi $t2, $s4, 1          # fixed center row
    add  $t3, $t7, $t1        # col = base col + offset
    mul  $t4, $t2, 512
    mul  $t5, $t3, 4
    add  $t6, $s0, $t4
    add  $t6, $t6, $t5
    sw   $t9, 0($t6)
    addi $t1, $t1, 1
    j draw_h
done_h:
    add $t7, $t7, $t8         # next star col
    j next_star
end_star_row:
    jr $ra

stars_done:

    ################################################################
    # DRAW RED PLANET (TOP LEFT, swirl pattern)
    ################################################################
    li   $t0, 2         # red planet base row
    li   $t1, 2         # red planet base col
    li   $t2, 24        # bounding box size
    li   $t3, 12        # radius
    addu $t8, $t1, $t3  # center_col = base col + 12
    addu $t9, $t0, $t3  # center_row = base row + 12
    li   $t4, 0         # Outer loop counter (i)
planet_row_loop:
    bge  $t4, $t2, planet_done
    addu $t6, $t0, $t4      # current_row = base row + i
    li   $t5, 0           # Inner loop counter (j)
planet_col_loop:
    bge  $t5, $t2, planet_next_row
    addu $t7, $t1, $t5      # current_col = base col + j
    sub  $a0, $t7, $t8      # dx = current_col - center_col
    sub  $a1, $t6, $t9      # dy = current_row - center_row
    mul  $v1, $a0, $a0      # dx^2
    mul  $t3, $a1, $a1      # dy^2 (temporary)
    addu $v1, $v1, $t3      # distance^2
    li   $t3, 144          # 12^2 = 144
    bgt  $v1, $t3, planet_skip_pixel
    sll  $v0, $a1, 1       # pattern: (2*dy + dx) >> 2
    addu $v0, $v0, $a0
    sra  $v0, $v0, 2
    andi $v0, $v0, 3      # mod 4
    li   $t3, 0
    beq  $v0, $zero, pick_darkest
    li   $t3, 1
    beq  $v0, $t3, pick_dark
    li   $t3, 2
    beq  $v0, $t3, pick_mid
pick_light:
    lw   $t3, light_red
    j    planet_set_pixel
pick_mid:
    lw   $t3, mid_red
    j    planet_set_pixel
pick_dark:
    lw   $t3, dark_red
    j    planet_set_pixel
pick_darkest:
    lw   $t3, darkest_red
planet_set_pixel:
    mul  $v1, $t6, 512         # row offset in bytes
    sll  $a0, $t7, 2           # col offset in bytes
    addu $v1, $s0, $v1        # base + row offset
    addu $v1, $v1, $a0        # final pixel address
    sw   $t3, 0($v1)          # store chosen red color
planet_skip_pixel:
    addi $t5, $t5, 1         # j++
    j    planet_col_loop
planet_next_row:
    addi $t4, $t4, 1         # i++
    j    planet_row_loop
planet_done:

    ################################################################
    # DRAW EARTH-LIKE PLANET (TOP RIGHT, swirl pattern)
    ################################################################
    li   $t0, 2         # earth planet base row
    li   $t1, 102       # earth planet base col
    li   $t2, 24        # bounding box size
    li   $t3, 12        # radius
    addu $t8, $t1, $t3  # center_col = base col + 12
    addu $t9, $t0, $t3  # center_row = base row + 12
    li   $t4, 0         # Outer loop counter (i)
earth_row_loop:
    bge  $t4, $t2, earth_done
    addu $t6, $t0, $t4      # current_row = base row + i
    li   $t5, 0           # Inner loop counter (j)
earth_col_loop:
    bge  $t5, $t2, earth_next_row
    addu $t7, $t1, $t5      # current_col = base col + j
    sub  $a0, $t7, $t8      # dx = current_col - center_col
    sub  $a1, $t6, $t9      # dy = current_row - center_row
    mul  $v1, $a0, $a0      # dx^2
    mul  $t3, $a1, $a1      # dy^2 (temporary)
    addu $v1, $v1, $t3      # distance^2
    li   $t3, 144          # 12^2 = 144
    bgt  $v1, $t3, earth_skip_pixel
    sll  $v0, $a1, 1       # pattern: (2*dy + dx) >> 2
    addu $v0, $v0, $a0
    sra  $v0, $v0, 2
    andi $v0, $v0, 3      # mod 4
    li   $t3, 0
    beq  $v0, $zero, pick_earth_dark
    li   $t3, 1
    beq  $v0, $t3, pick_earth_ocean
    li   $t3, 2
    beq  $v0, $t3, pick_earth_land
pick_earth_clouds:
    lw   $t3, earth_clouds
    j    earth_set_pixel
pick_earth_land:
    lw   $t3, earth_land
    j    earth_set_pixel
pick_earth_ocean:
    lw   $t3, earth_ocean
    j    earth_set_pixel
pick_earth_dark:
    lw   $t3, earth_dark
earth_set_pixel:
    mul  $v1, $t6, 512      # row offset in bytes
    sll  $a0, $t7, 2        # col offset in bytes
    addu $v1, $s0, $v1      # base address
    addu $v1, $v1, $a0      # final pixel address
    sw   $t3, 0($v1)        # store chosen earth color
earth_skip_pixel:
    addi $t5, $t5, 1       # j++
    j    earth_col_loop
earth_next_row:
    addi $t4, $t4, 1       # i++
    j    earth_row_loop
earth_done:

################################################################
# DRAW PLATFORMS (A–E)
################################################################
li $t9, 0x00808080       # Grey color

# Platform A: row 50, columns 10 to 30 (floating platform)
li $t4, 50
li $t5, 10
platA_loop:
    mul $t6, $t4, 512
    mul $t7, $t5, 4
    add $t8, $s0, $t6
    add $t8, $t8, $t7
    sw  $t9, 0($t8)
    addi $t5, $t5, 1
    blt  $t5, 31, platA_loop

# Platform B: row 40, columns 40 to 70
li $t4, 40
li $t5, 40
platB_loop:
    mul $t6, $t4, 512
    mul $t7, $t5, 4
    add $t8, $s0, $t6
    add $t8, $t8, $t7
    sw  $t9, 0($t8)
    addi $t5, $t5, 1
    blt  $t5, 71, platB_loop

# Platform C: row 30, columns 90 to 115
li $t4, 30
li $t5, 90
platC_loop:
    mul $t6, $t4, 512
    mul $t7, $t5, 4
    add $t8, $s0, $t6
    add $t8, $t8, $t7
    sw  $t9, 0($t8)
    addi $t5, $t5, 1
    blt  $t5, 116, platC_loop

# Platform D: row 25, columns 20 to 45
li $t4, 25
li $t5, 20
platD_loop:
    mul $t6, $t4, 512
    mul $t7, $t5, 4
    add $t8, $s0, $t6
    add $t8, $t8, $t7
    sw  $t9, 0($t8)
    addi $t5, $t5, 1
    blt  $t5, 46, platD_loop

# Platform E: row 45, columns 95 to 120
li $t4, 45
li $t5, 95
platE_loop:
    mul $t6, $t4, 512
    mul $t7, $t5, 4
    add $t8, $s0, $t6
    add $t8, $t8, $t7
    sw  $t9, 0($t8)
    addi $t5, $t5, 1
    blt  $t5, 121, platE_loop

    ################################################################
    # INIT PREVIOUS PLAYER POSITION
    ################################################################
    li   $s6, 60
    li   $s7, 2

######################################################################
# MAIN GAME LOOP
######################################################################
game_loop:
    ################################################################
    # 1) Handle Continuous Input with Delay
    ################################################################
    li   $t0, 0xffff0000      # Keyboard MMIO base
    lw   $t1, 0($t0)          # Read key status
    beq  $t1, $zero, reset_delay   # No key pressed: reset delay counter

    lw   $t2, move_delay_counter   # Load delay counter
    bnez $t2, decrement_delay       # If counter is not zero, skip input

    # A key is pressed and delay counter is 0; process input:
    lw   $t3, 4($t0)          # ASCII code
    li   $t4, 97              # 'a'
    beq  $t3, $t4, move_left
    li   $t4, 100             # 'd'
    beq  $t3, $t4, move_right
    li   $t4, 119             # 'w'
    beq  $t3, $t4, try_jump

decrement_delay:
    lw   $t2, move_delay_counter
    addi $t2, $t2, -1
    sw   $t2, move_delay_counter
reset_delay:
    # If no key is pressed, reset the counter to 0
    li   $t2, 0
    sw   $t2, move_delay_counter
    j skip_input

skip_input:
    ################################################################
    # 2) Restore Old Player Background from Buffer
    # (Iterate 4 rows × 4 cols)
    ################################################################
    la   $t3, player_bg_buffer
    li   $t8, 0
restore_bg_loop_rows:
    li   $t9, 0
restore_bg_loop_cols:
    add  $t4, $s6, $t8
    add  $t5, $s7, $t9
    mul  $t4, $t4, 512
    mul  $t5, $t5, 4
    add  $t0, $s0, $t4
    add  $t0, $t0, $t5
    lw   $t1, 0($t3)
    sw   $t1, 0($t0)
    addi $t3, $t3, 4
    addi $t9, $t9, 1
    blt  $t9, 4, restore_bg_loop_cols
    addi $t8, $t8, 1
    blt  $t8, 4, restore_bg_loop_rows

    ################################################################
    # 3) Apply Gravity (with floating platform collision)
    ################################################################
    jal  apply_gravity

    ################################################################
    # 4) Clamp & Save New Player Position
    # (Max row = 60, max col = 124 for 4x4 sprite)
    ################################################################
    la   $t0, player_row
    la   $t1, player_col
    lw   $t4, 0($t0)
    lw   $t5, 0($t1)
    li   $t6, 0
    blt  $t4, $t6, fix_top
    li   $t6, 60
    bgt  $t4, $t6, fix_bottom
    j    skip_row_clamp
fix_top:
    li   $t4, 0
    sw   $t4, player_row
    j    skip_row_clamp
fix_bottom:
    li   $t4, 60
    sw   $t4, player_row
skip_row_clamp:

    li   $t6, 0
    blt  $t5, $t6, fix_left
    li   $t6, 124
    bgt  $t5, $t6, fix_right
    j    skip_col_clamp
fix_left:
    li   $t5, 0
    sw   $t5, player_col
    j    skip_col_clamp
fix_right:
    li   $t5, 124
    sw   $t5, player_col
skip_col_clamp:

    lw   $t5, 0($t1)
    la   $t7, current_player_row
    sw   $t4, 0($t7)
    la   $t7, current_player_col
    sw   $t5, 0($t7)

    ################################################################
    # 5) Save New Background into Buffer
    # (Iterate 4 rows x 4 cols)
    ################################################################
    la   $t3, player_bg_buffer
    li   $t8, 0
save_bg_loop_rows:
    la   $t7, current_player_row
    lw   $t5, 0($t7)
    la   $t7, current_player_col
    lw   $t6, 0($t7)
    li   $t9, 0
save_bg_loop_cols:
    add  $t2, $t5, $t8
    add  $t1, $t6, $t9
    mul  $t2, $t2, 512
    mul  $t1, $t1, 4
    add  $t0, $s0, $t2
    add  $t0, $t0, $t1
    lw   $t4, 0($t0)
    sw   $t4, 0($t3)
    addi $t3, $t3, 4
    addi $t9, $t9, 1
    blt  $t9, 4, save_bg_loop_cols
    addi $t8, $t8, 1
    blt  $t8, 4, save_bg_loop_rows

    ################################################################
    # 6) Draw Player at New Position (4x4 sprite with eyes)
    ################################################################
    li   $t8, 0            # Row offset (0..3)
draw_loop_rows:
    la   $t7, current_player_row
    lw   $t5, 0($t7)       # Base row for player
    la   $t7, current_player_col
    lw   $t6, 0($t7)       # Base col for player
    li   $t9, 0            # Column offset (0..3)
draw_loop_cols:
    add  $t2, $t5, $t8     # current_row = base_row + row offset
    add  $t1, $t6, $t9     # current_col = base_col + col offset
    mul  $t2, $t2, 512     # row offset in bytes
    mul  $t1, $t1, 4       # col offset in bytes
    add  $t0, $s0, $t2     # pixel address = base + row offset
    add  $t0, $t0, $t1     # + column offset

    # Determine pixel color.
    # For all rows except row 1, draw red ($s2).
    # For row 1, choose eye color based on facing.
    li   $t3, 1
    bne  $t8, $t3, player_set_red   # if row offset != 1, set red

    # Now in row 1: load player_facing.
    lw   $t3, player_facing         # $t3 = 0 for right, 1 for left
    beq  $t3, $zero, right_facing    # if facing == 0, branch to right_facing

    # Left facing branch:
left_facing:
    li   $t4, 0
    beq  $t9, $t4, player_set_black  # if col offset == 0, set black
    li   $t4, 2
    beq  $t9, $t4, player_set_black  # if col offset == 2, set black
    j    player_set_red

right_facing:
    li   $t4, 1
    beq  $t9, $t4, player_set_black  # if col offset == 1, set black
    li   $t4, 3
    beq  $t9, $t4, player_set_black  # if col offset == 3, set black
    j    player_set_red

player_set_black:
    lw   $t7, black       # load black color
    j    store_pixel
player_set_red:
    move $t7, $s2         # set red color
store_pixel:
    sw   $t7, 0($t0)      # write chosen color

    addi $t9, $t9, 1
    blt  $t9, 4, draw_loop_cols
    addi $t8, $t8, 1
    blt  $t8, 4, draw_loop_rows

    ################################################################
    # 7) Update Previous Player Position
    ################################################################
    la   $t7, current_player_row
    lw   $t4, 0($t7)
    move $s6, $t4
    la   $t7, current_player_col
    lw   $t4, 0($t7)
    move $s7, $t4

    ################################################################
    # 8) Frame Delay
    ################################################################
    li   $v0, 32
    li   $a0, 40
    syscall

    j game_loop

######################################################################
# INPUT HANDLERS
######################################################################
move_left:
    lw   $t4, player_col
    li   $t5, 2
    ble  $t4, $t5, done_moving   # Prevent moving left if at or below boundary
    addi $t4, $t4, -4            # Subtract 2 units => 2*4 = 8 pixels
    sw   $t4, player_col
    # Set facing to left (1)
    li   $t6, 1
    sw   $t6, player_facing
done_moving:
    lw   $t7, move_delay_value
    sw   $t7, move_delay_counter
    j skip_input


move_right:
    lw   $t4, player_col
    li   $t5, 124
    bge  $t4, $t5, done_moving2  # Prevent moving right if at or beyond boundary
    addi $t4, $t4, 4             # Add 2 units => 2*4 = 8 pixels
    sw   $t4, player_col
    # Set facing to right (0)
    li   $t6, 0
    sw   $t6, player_facing
done_moving2:
    lw   $t7, move_delay_value
    sw   $t7, move_delay_counter
    j skip_input


try_jump:
    la   $t0, is_jumping
    lw   $t1, 0($t0)
    bnez $t1, game_loop
    li   $t1, 1
    sw   $t1, 0($t0)
    la   $t2, player_velocity
    li   $t3, -6
    sw   $t3, 0($t2)
    lw   $t7, move_delay_value
    sw   $t7, move_delay_counter
    j skip_input

######################################################################
# GRAVITY ENGINE (platform is fully solid: no climbing from below)
######################################################################
apply_gravity:
    la   $t0, is_jumping
    lw   $t1, 0($t0)
    la   $t2, player_row
    lw   $t3, 0($t2)       # old player row in $t3
    la   $t4, player_velocity
    lw   $t5, 0($t4)       # current velocity in $t5
    bnez $t1, apply_physics
    li   $t6, 60          # floor: max row = 60
    beq  $t3, $t6, done_gravity
    li   $t1, 1
    sw   $t1, 0($t0)
    li   $t5, 1
    sw   $t5, 0($t4)
    j    apply_physics

apply_physics:
    move $t6, $t3         # save old row in $t6
    add  $t3, $t3, $t5    # new row = old row + velocity

    # For collision checks, compute bottoms:
    addi $t7, $t3, 3      # new_bottom = new row + 3
    addi $t9, $t6, 3      # old_bottom = old row + 3

    # Branch based on velocity:
    bgtz $t5, check_downward         # if falling (velocity > 0)
    bltz $t5, check_upward_A         # if jumping (velocity < 0)
    j no_platform_collision          # if velocity == 0

#---------------- Downward Collision for Platform A (row 50, cols 10–30) ----------------
check_downward:
    slti $s4, $t9, 50          # $s4 = 1 if old_bottom < 50
    slti $s5, $t7, 50          # $s5 = 1 if new_bottom < 50
    beq  $s4, $zero, check_platform_B  # if old_bottom not less than 50, go to next
    bnez $s5, check_platform_B          # if new_bottom still less than 50, no collision with A
    j    check_horizontal_A

check_horizontal_A:
    lw   $s6, player_col      # player's left col
    addi $t8, $s6, 3          # player's right col = left + 3
    li   $s7, 31              # if player's left col >= 31, no collision
    bge  $s6, $s7, check_platform_B
    li   $s7, 10              # platform A left boundary = 10
    blt  $t8, $s7, check_platform_B  # if player's right col < 10, no collision
    # Downward collision detected for Platform A: clamp player's row to 50 - 4 = 46
    li   $t3, 46
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

#---------------- Downward Collision for Platforms B–E ----------------
# (As in your previous code; unchanged from earlier snippet.)
check_platform_B:
    slti $s4, $t9, 40
    slti $s5, $t7, 40
    beq  $s4, $zero, check_platform_C
    bnez $s5, check_platform_C
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 71
    bge  $s6, $s7, check_platform_C
    li   $s7, 40
    blt  $t8, $s7, check_platform_C
    li   $t3, 36
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_platform_C:
    slti $s4, $t9, 30
    slti $s5, $t7, 30
    beq  $s4, $zero, check_platform_D
    bnez $s5, check_platform_D
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 116
    bge  $s6, $s7, check_platform_D
    li   $s7, 90
    blt  $t8, $s7, check_platform_D
    li   $t3, 26
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_platform_D:
    slti $s4, $t9, 25
    slti $s5, $t7, 25
    beq  $s4, $zero, check_platform_E
    bnez $s5, check_platform_E
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 46
    bge  $s6, $s7, check_platform_E
    li   $s7, 20
    blt  $t8, $s7, check_platform_E
    li   $t3, 21
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_platform_E:
    slti $s4, $t9, 45
    slti $s5, $t7, 45
    beq  $s4, $zero, no_platform_collision
    bnez $s5, no_platform_collision
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 121
    bge  $s6, $s7, no_platform_collision
    li   $s7, 95
    blt  $t8, $s7, no_platform_collision
    li   $t3, 41
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

#---------------- Upward Collision Checks for Platforms A–E ----------------
check_upward_A:
    # For upward collision on Platform A (row 50)
    ble  $t6, 50, check_upward_B  # if old top <= 50, no collision here
    bgt  $t3, 50, check_upward_B  # if new top > 50, no collision
    j    check_horizontal_up_A
check_horizontal_up_A:
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 31
    bge  $s6, $s7, check_upward_B
    li   $s7, 10
    blt  $t8, $s7, check_upward_B
    # Upward collision detected for Platform A: clamp player's row to 51
    li   $t3, 51
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_upward_B:
    # For upward collision on Platform B (row 40)
    ble  $t6, 40, check_upward_C
    bgt  $t3, 40, check_upward_C
    j    check_horizontal_up_B
check_horizontal_up_B:
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 71
    bge  $s6, $s7, check_upward_C
    li   $s7, 40
    blt  $t8, $s7, check_upward_C
    # Upward collision detected for Platform B: clamp player's row to 41
    li   $t3, 41
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_upward_C:
    # For upward collision on Platform C (row 30)
    ble  $t6, 30, check_upward_D
    bgt  $t3, 30, check_upward_D
    j    check_horizontal_up_C
check_horizontal_up_C:
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 116
    bge  $s6, $s7, check_upward_D
    li   $s7, 90
    blt  $t8, $s7, check_upward_D
    # Upward collision detected for Platform C: clamp player's row to 31
    li   $t3, 31
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_upward_D:
    # For upward collision on Platform D (row 25)
    ble  $t6, 25, check_upward_E
    bgt  $t3, 25, check_upward_E
    j    check_horizontal_up_D
check_horizontal_up_D:
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 46
    bge  $s6, $s7, check_upward_E
    li   $s7, 20
    blt  $t8, $s7, check_upward_E
    # Upward collision detected for Platform D: clamp player's row to 26
    li   $t3, 26
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

check_upward_E:
    # For upward collision on Platform E (row 45)
    ble  $t6, 45, no_platform_collision  # if old top <= 45, no upward collision
    bgt  $t3, 45, no_platform_collision  # if new top > 45, no collision
    j    check_horizontal_up_E
check_horizontal_up_E:
    lw   $s6, player_col
    addi $t8, $s6, 3
    li   $s7, 121
    bge  $s6, $s7, no_platform_collision
    li   $s7, 95
    blt  $t8, $s7, no_platform_collision
    # Upward collision detected for Platform E: clamp player's row to 46
    li   $t3, 46
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    j    done_gravity

# If no upward collision detected for any platform:
no_platform_collision:
    bgt  $t3, 60, set_floor
    sw   $t3, player_row
    addi $t5, $t5, 1
    sw   $t5, player_velocity

done_gravity:
    jr   $ra

set_floor:
    li   $t3, 60
    sw   $t3, player_row
    li   $t5, 0
    sw   $t5, player_velocity
    li   $t1, 0
    sw   $t1, is_jumping
    jr   $ra

end:
    j end
